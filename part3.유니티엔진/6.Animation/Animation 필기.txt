[ Animation 기초 ]
움직임에 애니메이션을 달아보자.
(사실 애니메이션 파일은 rig에서 볼수있는 애니메이션타입에 따라서, 타입만 맞으면 다른 객체에도 사용할 수 있다.//휴머노이드 타입의 다른 에셋에도 유니티짱의 RUN을 쓸수있음)

애니메이션도 컨트롤러로 조종한다.
유니티짱을 보면 animators라는 컨트롤러 파일도 있지만, 우린 학습을 위해 실제로 만들어보자.(PlayerAnimController)

Animaotr파일에 애니메이션들을 추가했고, PlayerController파일에서 플레이어의 위치가 변하는 부분에
if(_moveToDest)
        {
            Animator anim = GetComponent<Animator>();
            anim.Play("RUN");
        }
else
        {
            Animator anim = GetComponent<Animator>();
            anim.Play("WAIT");
        }
위같은식의 코드를 추가해 상태를 바꾸는 식으로 애니메이션을 동작시켜봤다.

[ Animation Blending ]
그러나 위같은 코드로 RUN, WAIT을 바꿔주면, 캐릭터가 설때 순간적으로 애니메이션이 바껴 굉장히 어색하다.
애니메이션을 서서히 멈추게하는 Blending 기술을 사용해보자. 일정 퍼센트는 WAIT을 일정 퍼센트는 RUN을 플레이시키게 섞는것.
new Blend Tree를 만들자.
여기서 여러개의 애니메이션을 섞을수있다.
그리고 애니메이션들을 섞는 값, 패러미터로 Blend, Float, Int, Bool, Trigger등등이 있다. 이번에는 float사용함.

다시 Animator파일로 돌아가 이제는 WAIT,RUN을 사용하는것이 아닌 둘다 WAIT_RUN을 사용하고, wait_run_ratio를 상황에맞춰 변화시키면된다.
wait_run_ratio가 자연스럽게 커지고 작아져야하므로 Mathf.Lerp(대상, 목표치, 소모시간)를 이용했다.

[ State 패턴 ]
그런데 위처럼 애니메이션마다 블렌딩을 맞춰주는건 말이안됨. (상태가 걷고서기처럼 2개를 블렌딩만 하면 되는게 아니라는말)
그리고 블렌딩을 하더라도 if else문으로 처리하면 굉장히 복잡해지고 관리가 안됨 = 스파게티코드.

그렇기에 이걸 관리하는 최고의 방법은 State패턴이다!
public enum PlayerState
{
Die, Moving, Idle,...
}
이렇게 스테이트를 준비해주고, 업데이트문에서는 if else문을 쓰는게아니라, switch문을 통해 나의 상태에 해당하는 코드를 작동시키면된다.

//키보드로의 이동은 없애버렸다. OnKeyboard( )문 & _moveToDest도 삭제(이런거 삭제하려고 state패턴 쓰는거니까). 이로인해 이동코드들 세부사항이 조금씩 바꼈다.

이 경우 switch문을 통해 좀더 경제적으로 정리할수있었다. 대신 단점으로는 한번에 두가지 state를 가질수는 없다. (움직이면서 칼을 휘둘러야된다면, 이때 까다로워짐)

상태별로 코드를 짤수있고, 그 상태를 변화시키는 코드와 로직이 이번 state패턴의 핵심

[ StateMachine #1 ]
저번에 만든 AnimatorController처럼 state들을 눈으로 볼수있게 모아논것을 state머신이라한다.
여기서는 각각의 state들이 어떨때 변화하는지(언제 run에서 wait으로 가는지)가 중요하다.
(게다가 stateMachine은 아예 툴에서 setting을 통해 블렌딩을 할수도있더라)

지금까지는 state가 3개밖에 없어서 코드로 다루는게 편했지만, state가 엄청 많아지면 stateMachine툴을 사용하는게 편하다.
//이젠 StateMachine을 쓸거니 wait_run_ratio와 상태를 변화시켰던 코드를 지웠다.(PlayerController)

wait과 run을 서로 연결(Transition)해주면 실행했을때, 뛰다 서다 뛰다 서는 모션이 나온다. => Has Exit Time에 체크가 되어있어서 그렇다. 애니메이션 시간이 끝나면 자동으로 다음 상태로 넘어가게되는것
그런데 이게 있어야지 서로 왔다갔다할수있음. 안켜주면 그냥 상태가 변하질않음.
 
[ StateMachine #2 ]
위같이 자동으로 모션이 넘어가는 것에 무슨 이점이 있을까? 하나가 끝나면 자동으로 넘어가야하는 정해진 경우에 유용함.(점프시작-솟아오름-내려옴-착지)
그리고 모션의 경우 loop 속성이 있다. 모션이 끝난후 반복되서 실행되는 속성임. 나중에 모션끼리 연결했을때 자동으로 실행이 안되는경우도 있다해서 말함.

이제 자동이아닌, 강제로 transition을 왔다갔다하는 방법을 알아보자
조건에 의해 움직이게할거니 Has Exit Time꺼주기
상태별로 움직이게하는 조건은, 예전에 wait_run_ratio만들었던것처럼, 패러미터에 따라 스스로 넘어갈지 말지 판단하게하면된다.=>transition의 condition에 아까만든 패리미터를 추가한다.
이번실습에서는 speed라는 float 패러미터를 만들었다.

이제 우린 코드에서 패러미터를 변화시키는 코드만 짜면 자동으로 상태를 변화시킬수있는거다.
Animtor anim을 정의하고 anim.SetFloat을 통해 상태를 계속 통신하는것.

//그런데 만약 스킬모션을 넣는다 치면 위 과정조차 하드코딩이 되어버릴 것임. 그래서 이동,대기와 같은 공통적인 모션들은 stateMachine을 쓰고 스킬은 앞서했던것처럼 코딩으로 블렌딩해주는경우가 많다고한다.

[ KeyFrame Animation ]
그동안 애니메이터가 만든 애니메이션을 사용했다. 그런데 캐릭터에 종속적인 애니메이션이 아니라, 게임 자체에 종속적인 애니메이션을 만들순없을까? (게임하늘에 날아다니는 새처럼)//솔직히 말을 너무 이상하게한다.
=>게임에 연관이 있는거지 새한테 개인 애니메이션을 준게아니다.
==>게임의 rotation이나 경로에 따른 애니메이션을 만들면좋겠다. (배우에게 어디서는 어떤 애니메이션을 해라하고 지시하는것) (특정 카드판 위로 날라가는 카드 모션)
큐브를 움직이는 애니메이션을 만들어보자 (Window-Animation)

AddKey = 이 지점에서 무언가 발생할것이다.
사용예시) 게임은 계속 변화하는 프레임의 연속인걸 생각하면, 매 프레임마다의 위치를 설정해줄수는 없다. 그래서 addKey는 특정지점(시간)에만 값을 정해주고, 중간과정은 보정(curve)을해서 넣어주게된다.
좌표로 설정하는게 아니라, 실제 눈으로 보이는 위치로 설정해줄순없나? 있다. Preview옆에 Record빨간점을 누르면, 시간대마다 물체가 움직이는게 나온다. 그걸 수정하고 싶다면 해당 시간대에서 scene의 qwer을 통해 수정을 주면된다. =이게 수정하는 가장 현실적 방법이래.
다 해주고 Record를 끝내면 저장됨.

!! 즉, 특정시간에 어떤 위치에 있으라고 정해주면, 그 사이는 적당히 보정되서 채울수있다

[ Animation Event ]
KeyFrame Animation에서 3번째 줄이 AddKey 였고, 2번째 줄이 바로 Add Animation Event다.
Animation Event : 어떤 기능(event)을 애니메이션 시간과 맞춰줄때 사용한다. ex) 상자가 움직이는 애니메이션에서, 꼭대기에 다다르면 소리를 낸다는 식으로, or 꼭대기에 가면 서버에 패킷을 보낸다(미션성공 이런거).
=>애니메이터의 타임라인이 쭉 흐르다가, AnimationEvent 파란줄과 만나면, event를 코드에 쫙 뿌리게되고, 이걸 콜백방식으로 받아서 사용하면된다.

이상한것이, 큐브를 선택하지 않고 animation Event를 add하면 event Function의 이름이나 여러가지를 설정할 수 있는데,
큐브를 선택한채로 add하면 불가능하고, 만들어둔 function을 연결하는 형식으로 해야함...
(그리고 펑션을 연결하려면 큐브에 연결 component를 추가해야됨=연결하는 스크립트를 만들자) (=>이 펑션에는 큐브에 적용된 컴포넌트 스크립트에서 만들었던 함수들이 전부 뜨더라. PlayerController 잠시 달아보니까, OnClick도 나옴)
//그리고 큐브 선택안하고 function만드는건 별로 안좋은 방법인거같음.

당연하게도 Animatino Event는 기존 애니메이션에도 추가할 수 있다.(애니메이터가 만든 그런거들)
ex) 걷는 모션에서, 발이 닿는 시간을 찾아, 해당 타임라인에 event로 발소리를 내게 할 수도 있겠다.
그러한 이벤트는 해당 객체 내의 어떤 컴포넌트든지 receiver가 존재하면된다
(그리고 필요에 따라서 event에 있는 float, int, string, object를 전달해줄수도있다.)
void OnRunEvent(int a) {}
대신 얘는 오버로딩 불가능 (같은이름으로 인자 다른거) 위에있는 애만 작동하더라.