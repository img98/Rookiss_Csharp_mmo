[ prefab #1 ] 
Prefab = Pre-Fabrication = 일종의 붕어빵틀
유니티에서 component와 prefab 두가지 개념이 굉장히 중요함

Hierarchy에서도 드래그앤드랍으로 다수의 메쉬들을 하나의 메쉬안에 넣을수있다.
여기서 신기한것이, 메쉬를 이동시켰을때 상위메쉬(Tank)의 position좌표는 움직이지만 하위메쉬(Body,Top...)의 좌표는 변하지 않는다.
=> 그이유는, 메쉬를 소속시키면 하위메쉬는 상위메쉬의 자식같은 관계로, 부모의 좌표를 기준으로 표시하기 때문이다.
(그러면 로컬좌표가 아니라 월드좌표를 보고싶다면 어떻게해야할까? = 소속밖으로 잠깐 빼서 보고 다시 넣으면됨)

이렇게 부모자식 관계로 좌표를 계산하게되면 특정부위만 움직이는 모션(ex. 고개돌리기)을 구현하기 쉬워진다
& 손에 무기를 쥐고 팔흔들기(월드좌표로 손의 움직임에 따라 무기 좌표를 변화시킨다면 맞춘다면 힘들겠지만, player산하의 손좌표에 로컬좌표로 위치시키면 쉬워짐)

위처럼 만든 Tank(상위메쉬)를 project폴더에 드래그드랍하면 Prefabs파일이 생성됨.

Prefabs = 일종의 붕어빵틀. ( 왜씀? = 코딩할때 Body만들기 Top만들기...컴포넌트 부착 등등의 과정을 거칠 필요 없이 이 prefab을 불러오기만 하면 한방의 해결됨)
마치 c#의 클래스(class)와 비슷하다.

prefab을 수정하는 법 : prefabs파일을 더블클릭하면 프리팹모드로 들어가진다. 여기서 수정을하면 자동저장됨.

[ Prefabs #2 ]
Prefabs의 장점은 c#클래스처럼, prefab자체를 수정하면 얘로 생성된 모든 인스턴스들을 한번에 수정할수 있다는 것이다.

물론 Prefabs도 클래스처럼 각각의 객체마다 속성(ex. Speed)을 다르게 해줄수있음
그냥 원하는 객체(메쉬)로 가서 컴포넌트를 수정해주면 되는데, 이것을 '오버라이드'라 함.
오버라이드 했음을 표시하기 위해, 해당 속성은 볼드체로 변함.

<새로운 Prefab기능>
Nested Prefab = 마치 C#에서 클래스 안에 다른 클래스를 포함시키던 것처럼, Prefab안에 또다른 Prefab을 포함시킴. (nested=중첩된)
Prefab Variant = C# 상속 개념. 부모클래스를 상속받아서 무언가 추가시키거나 변형시킬수있음. (만드는법: 생성된 prefab을 다시 project폴더에 드래그드랍)

[ Resource Manager ]
prefab 인스턴스를 코드 상에서 만드는법을 다뤄보자.
Instantiate문을 쓰면된다. (유니티 툴의 장점으로, 유니티에서 prefab을 Instantiate문의 인자와 연결시켜주면 간단하게 해결된다.)
삭제하고싶으면? Destroy문

위에서 툴로 prefab을 연결할수있다했는데, 게임규모가 커지면 이 방법은 쓰기 힘들어질거다.
코드에서 Resources.Load를 이용하자
prefab = Resources.Load<GameObject>("Prefabs/Tank"); //여기서 의문점. Tank는 Asset\Resources\Prefabs 산하에 있다. 인자경로에 Asset은 그렇다쳐도 왜 Resources는 넣지않아도 작동될까?

[ 폴더 정리 ] 말그대로 쓸모없는 폴더랑 파일들 지움(유니티짱 폴더에서 안쓰는애들 지움)
앞으론 모든 모델들을 resources의 art에 추가하는 방식으로 진행할것(유니티짱, 스켈레톤 등)
셰이더 = 빛이 모델을 통과할때, 어떻게 반사될것인지 정의하는 파일