using System;

namespace Csharp
{
    class 데이터갖고놀기
    {
        /* ctrl + B 를 통해 빌드를 하고 디버깅 시작을한다.
         빌드를 통해서 오류를 찾을수 있으며 이로써 작업을 진행한다. */

        //데이터 + 로직 = 컴퓨터가 이해가능
        // ex) 체력0 + 0이면 죽음 = 캐릭터사망

        static void Main(string[] args) 
        {
            //ch1. 정수형식
            //byte(1바이트 0~255), short(2바이트  -3만~3만), int(4바이트), long(8바이트) -얘네를 자주 사용
            //sbyte(1바이트 -128~127), ushort(2바이트 0~6만), uint, ulong /s= 음수도표현 u=양수만표현
            int hp = 100;
            byte level; //만약 레벨상한이 0부터 100까지라면 바이트만 사용해도 충분하다.

            long id; //아이템 고유식별번호 사용에 유용

            //일화 : 문명에서 간디가 폭력적으로 변한 이유?
            byte attack = 0;
            attack--;
            //위와같은 로직이였는데 0에서 -1이 되자 언더플로우가 발생해 attack이 다시 255가됨.

            //ch2. 10진수 2진수 16진수
            /*2진수<->16진수 간의 변화는 쉽다
            그저 2진수 4자리를 모아서 16진수로 변화시켜주면됨
            0b10001111 -> 0b 1000 1111 -> 0x 8 F -> 0x8F */

            //ch3. 정수 범위의 비밀
            /* 2의 보수? 8개의 비트중 맨 왼쪽을 부호로 사용
             맨 왼쪽이 1이면 (1000 0000) -128을 의미
            그리고 뒤 7자리는 무조건 양을 표현함. 그렇기에 -127을 표시하고싶으면(1111 1111) = -128+127=-1
             */

            //ch4. 불리언,소수,문자,문자열형식
            bool b; // True or False , 1byte나 된다.(0혹은1만 쓰는데?)->연산과정에선 byte로 쓰는게 더빨라서임

            //소수. (정수보다 더 cost가 많이드는 연산임. 왠만하면 정수쓰자)
            float f = 3.14f; //4byte 기본적으로 소수는 double로 인식하기에 float쓸거면 f넣어야함
            double d = 3.14; //8byte 정밀도 더 뛰어남

            //문자
            char c = 'a'; //2byte ex)abc 는 한글자가 아니라 안됨
            string str = "abc"; //큰 따옴표 써야됨

            //ch5. 형식 변환
            //case1. 바구니 크기가 다른 경우
            int a = 1000;
            short b = (short)a; //short가 int보다 더 작은 바구니이기에 넣을 수없다. (short)a 를 사용해 "캐스팅" 해줘야함

            short b = 1000;
            int a = b; //이경우 작은곳에서 큰곳으로 간거라 괜찮다.

            //case2. 바구니 크기는 같지만 부호가 다를경우
            byte c = 255;
            sbyte  sb= (sbyte)c;
            //0xFF = 0b11111111 = -1이기에 이진수는 갖지만 읽는방법이 달라져서 다른 결과가 나온것.->오버/언더플로우

            //case3. 소수변환
            float f = 3.1414f;
            double d = f; //이경우 f와 정확한 값이 나오지 않음.인접한 값이 나옴->작은 오류가 생길수잇음

            //ch6. 데이터연산-가공
            int hp = 100;
            //사칙연산 + - * / %
            hp = 100 + 1;
            hp = 100 - 1;
            hp++;
            --hp;
            Console.WriteLine(hp);

            //비교연산 < <= > >= == !=
            bool b = hp < 100;
            Console.WriteLine(b);

            //논리연산 && AND , || OR , ! NOT
            //살아있는 고렙 유저인가요?
            int level = 50;
            bool isAlive = (hp > 0);
            bool isHighLevel = (level >= 40);

            bool a = isAlive && isHighLevel;

            //ch7. 비트연산 (자주쓰는건아닌데 알아두면 좋다)
            int num = 1;
            // << >>(쉬프트) &(and) |(or) ^(xor) ~(not)
            num = num << 1; //비트의 자리수를 왼쪽으로 1 옮긴것 0001 -> 0010
            //이로인해 오버플로우나 언더플로우가 나면 난리남
            //그래서 uint로 바꿔서 계산하는게 편함

            uint num = 1;
            Console.WriteLine(num);

            // &연산을 한다는 것은 0010&1100처럼 같은 자리수의 0,1 을 and연산해 1로 출력 -> 0000 //둘다 1이어야 1
            // |연산 둘중 하나만 1이면 1 (or)
            // ^ 두 값이 다르면 1로 설정 (xor) , 암호학에서 자주사용됨. 한값에 xor을 두번넣으면 처음값이 나옴
            int id = 123;
            int key = 401;
            int a = id ^ key; //이경우 암호화된 id가 나옴
            int b = a ^ key; //이경우 해독된 a, 즉 원래 id가 나옴


            // ~ 하나로만 연산하는것, 당연히 0->1, 1->0으로 바꿔치기 0010->1101 (not)

            // id관련 로직에 사용한다네

            //ch8. 할당연산?
            int a;
            a = 100;

            int b;
            b = a;

            a = a + 1;
            a += 1;

            a = a - 1;
            a -= 1;
            
            a *= 1;

            a /= 1;

            //그냥 이렇게 줄여쓸수있다.

            //이러한 연산간의 우선순위
            // 1. ++ --
            // 2. * / *
            // 3. + -
            // 4. << >>
            // 5. < >
            // 6. == !=
            // 7. & 8. ^ 9. | ....
            //솔직히 외우는 사람도 없고 이렇게 쓰면 가독성 떨어짐.
            //조금이라도 중요하다고 느껴진다면 괄호를 사용해라  int result=(a+3)*b;


            //안알려준거긴한데 알아서 타입을 찾아가는 변수형이 있다. var.
            var num 3;
            var num = "hello world"; //string num = "hello world"와 같은 효과다.
            //그런데 이러면 나중에 알아볼때 어려울수 있다. 그러니 그냥 명시적으로 원래대로 쓰는게 좋을거같다.
            
            Console.WriteLine("Hello World! {0}", hp);
        }
    }
}

