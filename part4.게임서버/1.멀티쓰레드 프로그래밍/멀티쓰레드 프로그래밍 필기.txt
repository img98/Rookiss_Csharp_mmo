[ 서버 OT ]
서버 = 다른 컴퓨터에서 연결 가능하도록 "대기 상태로 상시 실행중인 프로그램."

웹서버 = HTTP서버. 질의/응답 형태 => 드물게 정보 요청/갱신 한다면 효과적임 & 서버가 클라에게 접근할 일이없다.
게임서버 = TCP, 바이너리, 스테이트풀 서버 등등.. , 실시간 Interaction이 있다. => 이 실시간이 핵심임. 언제라도 서버가 클라에게 접근할 수 있어야함. 

서버에 관해서는, 식당 운영에 비유가능

[ 환경 설정 ]
새로운 프로젝트 : Server 
솔루션 및 프로젝트를 같은 디렉터리에 배치 - 해제 => 서버작업할때는 한 솔루션에 여러 프로젝트를 넣을것
(더미클라이언트=다용도테스팅, 서버=나중에사용할 진짜 서버, 서버코어=필요한 기능이 들어있는 프로젝트(서버의 기능이 담길것))

비쥬얼스튜디오의 솔루션은 한번에 여러개의 콘솔(실행창)을 켤수있다. 이것을 이용할것 => 서버와 클라를 동시에 띄울수있다.
일단은 서버코어에서만 작업할거임.

[ 멀티쓰레드 개론 ]
서버를 알기위해서는 멀티쓰레드를, 멀티쓰레드를 알기위해선 컴퓨터 구조를 알아야한다.

멀티쓰레드란 = cpu코어가 아주 짧은기간동안, 여러개의 쓰레드를 하나씩 작동함. 짧은기간동안 빠르게 이동하였기에 마치 한꺼번에 작동하는것처럼 보임

cpu 코어: 인간의두뇌, 프로그램을 작동시키는 주체. //노동자의 수
쓰레드 : 식당의 직원. //노동자의 손 갯수(손이 많으면 한번에 여러일도 할수있고 좋지만, 정작 노동자의 머리(cpu)가 적으면 한번에 여러 생각을 하기엔 어려움이 있으니 손이 꼬이게 된다.)

[ 쓰레드 생성 ]
비쥬얼스튜디오를 켰을때, Main함수가 하나의 쓰레드 가 된다. 
그리고 그 안에 Thread t = new Thread(만든쓰레드이름); 같은 코드를 넣으면 새로운 쓰레드를 추가 즉, 멀티쓰레드를 사용할 수 있다.
이렇게되면 개론에서 말했던 것과 같이 main과 t쓰레드가 동시에 돌고있는걸 볼 수 있다. (main에는 A를 출력, t에는 B를 출력하게하면 AAABBBBAAA...이런식으로 같이나오는걸 볼수있다!)

그러나 쓰레드를 늘리는건 굉장히 부담이 되기에(직원을 새로 채용하면 보험도 챙겨주고, 인건비도 두배들고...)
=>ThreadPool을 통해 일시적으로 사용하는(특정 임무만 수행하면 사라지는) 쓰레드를 꺼내쓸 수 있다. (마치 인력사무소에서 대기중인 인부를 갖다쓰는것과 같다)
=이걸 ThreadPooling, 쓰레드 풀링이라한다 (풀이라는 대기소에 담아두기) //저번에 한건 오브젝트 풀링
그리고 위에서 말했듯, 결국 중요한건 cpu코어다. 그래서 아주많은 작업을 하고싶다고 쓰레드를 무작정 늘리게되면, 오히려 cpu가 쓰레드 사이를 이동하는데 걸리는 시간이 더걸리는 참사가 생긴다.
그렇기에 사실 쓰레드와 cpu코어의 수를 맞춰주는게 좋다.

쓰레드풀링은 위같은 경우를 해결하기 위해, min/maxThread의 갯수를 설정할수있다.
그렇지만 제한을 둔것이기에 만약 max이상의 작업(thread)를 돌리려고 하면, max를 넘어간 작업은 수행되지 않는다.
=> 이걸 보완하려고 만든게 Task다. 직원을 고용한다기보다는 직원의 일감을 지정해주겠다.
오래걸리는 작업은 굳이 쓰레드를 만들게 아니라, Task을 만들어서 max이상의 쓰레드가 돌게 할 수 있다.//LongRunning 인자를 추가하더라. (물론 인자 추가를 안해주면, max초과하면 작동안함)

! 쓰레드 / 쓰레드풀 / 태스크에 대한 개념
!! 여러작업 동시돌리기 / 쓰레드 재사용을 좀더 용이하게 / 쓰레드 갯수를 좀더 유연하게 쓰기위한것들

[ 컴파일러 최적화 ]
상용화를 하게되면 release모드를 사용하게 되는데, 이경우 디버깅이 더 어려워짐. Debug모드때와 같은코드인데 결과가 다름..
그 이유는 디버그-창-디스어셈블리 에서 볼 수 있는데, 말그대로 어셈블리어로 코드가 어떻게 돌아가는지 보여줌
문제는 ThreadMain의 while(_stop==false) // 릴리스 모드에서는 if(_stop==false){ while(ture) } 로 최적화해서 쓰레드 종료가 안나오더라!!

이것을 해결하려면 volatile을 사용하여 특정 변수는(_stop)은 최적화 하지 말라고 설정할 수 있다. (c# c++모두 있는기능이지만, 내용이 조금다름) 
c#에선 너무 특이해서, 사실 쓰지말라고 한다. 다른 방법도 많다.

!오늘의 핵심, 릴리스모드에서는 코드최적화로 인해, 예상치 못한 혹은 없던 버그도 생길수있다!

[ 캐시 이론 ]
음식점을 예로 들어보자, 매번 주문이 들어올때마다 카운터에 말하면 경로적손해나 시간적 손해가 생긴다. 그렇기에 최대한 기억해놨다가 한번만 카운터로가서 기억(주문)을 넘겨준다.
cpu도 직원과 같다. 내부에 ALU(연산장치)와 캐시가들어있고, 매 연산마다 RAM(메모리=카운터)에 접근하면 낭비가 심하다.
그렇기에 캐시에다가 최대한 기억을 저장해 놓고, 한번에 메모리에 전달하는 것이다.

캐시 철학 - 별거아닌거같지만 멀티쓰레드 환경이 되면 중요해진다.
1. Temporal Locality 시간적으로, 방금 들어온 명령을 또 쓸 가능성이 높다.= 방금의 명령을 기억해 놓으면 편하지 않을까?
2. Spcial Locality 공간적으로, 방금 명령이 들어온 부분에서 또 명령이 나올확률이 높다. = 방금 명령을 내린곳 근처의 명령도 기억하면 좋지 않을까?

캐시의 문제점.
캐시로 명령을 바꾼다고했을때, 이것은 메모리에 아직 들어가지 않은 수정사항이기에, 만약 멀티쓰레드 상황이라고 치면
1번쓰레드가 알고있는 정보와 2번쓰레드의 정보가 다를수 있다.

[ 메모리 배리어 ]
저번에 컴파일러 최적화로 인해 코드에 버그가 생긴것처럼, 하드웨어 최적화도 비슷한 것이 있다.
메모리도 각 코드간 별로 연관성이 없는것 같다고 판단한다면, 하드웨어(메모리)에서 사용하기 편하게 명령의 순서를 수정한다.
해결법 : 명령의 순서에 강제성을 추가한다. => 메모리 배리어

메모리 배리어의 용도?
1. 코드 재배치 억제 = 코드 중간에 MemoryBarrier()라는 선을 그어서, 이선을 넘어서까지 코드 재배치를 하진 말아라 하는것.
-> 데이터의 저장(Store)과 호출(Load)를 막는걸 Full Memory Barrier 라고한다. (ASM MFENCE, C# Thread.MemoryBarrier) , store만 load만 막는애들도 있는데 여까지는 잘안쓴다.

2. 가시성 = 저번 캐시때 말한것처럼, A의 캐시에 들어있는 정보를 B가 바로 볼수있게 하느냐를 말한다.
->가시성을 보장하기 위해서는 A가 캐시의 데이터를 메모리에 저장하고 B가 그것을 갱신하는 순서를 지켜줘야한다. (B는 업무를 보기전에 메모리를 commit받아온후 업무를 시작하면됨)

//어떻게보면 MemoryBarrier()는 이 위까지 한일을 메모리에다 커밋함과 동시에 그사이에 일어났을 다른 변화들을 커밋 받아온다 , 그후에 아래 일들을 수행한다고 볼수있다.

