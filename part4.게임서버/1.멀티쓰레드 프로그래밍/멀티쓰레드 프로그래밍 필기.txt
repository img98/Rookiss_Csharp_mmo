[ 서버 OT ]
서버 = 다른 컴퓨터에서 연결 가능하도록 "대기 상태로 상시 실행중인 프로그램."

웹서버 = HTTP서버. 질의/응답 형태 => 드물게 정보 요청/갱신 한다면 효과적임 & 서버가 클라에게 접근할 일이없다.
게임서버 = TCP, 바이너리, 스테이트풀 서버 등등.. , 실시간 Interaction이 있다. => 이 실시간이 핵심임. 언제라도 서버가 클라에게 접근할 수 있어야함. 

서버에 관해서는, 식당 운영에 비유가능

[ 환경 설정 ]
새로운 프로젝트 : Server 
솔루션 및 프로젝트를 같은 디렉터리에 배치 - 해제 => 서버작업할때는 한 솔루션에 여러 프로젝트를 넣을것
(더미클라이언트=다용도테스팅, 서버=나중에사용할 진짜 서버, 서버코어=필요한 기능이 들어있는 프로젝트(서버의 기능이 담길것))

비쥬얼스튜디오의 솔루션은 한번에 여러개의 콘솔(실행창)을 켤수있다. 이것을 이용할것 => 서버와 클라를 동시에 띄울수있다.
일단은 서버코어에서만 작업할거임.

[ 멀티쓰레드 개론 ]
서버를 알기위해서는 멀티쓰레드를, 멀티쓰레드를 알기위해선 컴퓨터 구조를 알아야한다.

멀티쓰레드란 = cpu코어가 아주 짧은기간동안, 여러개의 쓰레드를 하나씩 작동함. 짧은기간동안 빠르게 이동하였기에 마치 한꺼번에 작동하는것처럼 보임

cpu 코어: 인간의두뇌, 프로그램을 작동시키는 주체. //노동자의 수
쓰레드 : 식당의 직원. //노동자의 손 갯수(손이 많으면 한번에 여러일도 할수있고 좋지만, 정작 노동자의 머리(cpu)가 적으면 한번에 여러 생각을 하기엔 어려움이 있으니 손이 꼬이게 된다.)

[ 쓰레드 생성 ]
비쥬얼스튜디오를 켰을때, Main함수가 하나의 쓰레드 가 된다. 
그리고 그 안에 Thread t = new Thread(만든쓰레드이름); 같은 코드를 넣으면 새로운 쓰레드를 추가 즉, 멀티쓰레드를 사용할 수 있다.
이렇게되면 개론에서 말했던 것과 같이 main과 t쓰레드가 동시에 돌고있는걸 볼 수 있다. (main에는 A를 출력, t에는 B를 출력하게하면 AAABBBBAAA...이런식으로 같이나오는걸 볼수있다!)

그러나 쓰레드를 늘리는건 굉장히 부담이 되기에(직원을 새로 채용하면 보험도 챙겨주고, 인건비도 두배들고...)
=>ThreadPool을 통해 일시적으로 사용하는(특정 임무만 수행하면 사라지는) 쓰레드를 꺼내쓸 수 있다. (마치 인력사무소에서 대기중인 인부를 갖다쓰는것과 같다)
=이걸 ThreadPooling, 쓰레드 풀링이라한다 (풀이라는 대기소에 담아두기) //저번에 한건 오브젝트 풀링
그리고 위에서 말했듯, 결국 중요한건 cpu코어다. 그래서 아주많은 작업을 하고싶다고 쓰레드를 무작정 늘리게되면, 오히려 cpu가 쓰레드 사이를 이동하는데 걸리는 시간이 더걸리는 참사가 생긴다.
그렇기에 사실 쓰레드와 cpu코어의 수를 맞춰주는게 좋다.

쓰레드풀링은 위같은 경우를 해결하기 위해, min/maxThread의 갯수를 설정할수있다.
그렇지만 제한을 둔것이기에 만약 max이상의 작업(thread)를 돌리려고 하면, max를 넘어간 작업은 수행되지 않는다.
=> 이걸 보완하려고 만든게 Task다. 직원을 고용한다기보다는 직원의 일감을 지정해주겠다.
오래걸리는 작업은 굳이 쓰레드를 만들게 아니라, Task을 만들어서 max이상의 쓰레드가 돌게 할 수 있다.//LongRunning 인자를 추가하더라. (물론 인자 추가를 안해주면, max초과하면 작동안함)

! 쓰레드 / 쓰레드풀 / 태스크에 대한 개념
!! 여러작업 동시돌리기 / 쓰레드 재사용을 좀더 용이하게 / 쓰레드 갯수를 좀더 유연하게 쓰기위한것들

[ 컴파일러 최적화 ]
상용화를 하게되면 release모드를 사용하게 되는데, 이경우 디버깅이 더 어려워짐. Debug모드때와 같은코드인데 결과가 다름..
그 이유는 디버그-창-디스어셈블리 에서 볼 수 있는데, 말그대로 어셈블리어로 코드가 어떻게 돌아가는지 보여줌
문제는 ThreadMain의 while(_stop==false) // 릴리스 모드에서는 if(_stop==false){ while(ture) } 로 최적화해서 쓰레드 종료가 안나오더라!!

이것을 해결하려면 volatile을 사용하여 특정 변수는(_stop)은 최적화 하지 말라고 설정할 수 있다. (c# c++모두 있는기능이지만, 내용이 조금다름) 
c#에선 너무 특이해서, 사실 쓰지말라고 한다. 다른 방법도 많다.

!오늘의 핵심, 릴리스모드에서는 코드최적화로 인해, 예상치 못한 혹은 없던 버그도 생길수있다!

[ 캐시 이론 ]
음식점을 예로 들어보자, 매번 주문이 들어올때마다 카운터에 말하면 경로적손해나 시간적 손해가 생긴다. 그렇기에 최대한 기억해놨다가 한번만 카운터로가서 기억(주문)을 넘겨준다.
cpu도 직원과 같다. 내부에 ALU(연산장치)와 캐시가들어있고, 매 연산마다 RAM(메모리=카운터)에 접근하면 낭비가 심하다.
그렇기에 캐시에다가 최대한 기억을 저장해 놓고, 한번에 메모리에 전달하는 것이다.

캐시 철학 - 별거아닌거같지만 멀티쓰레드 환경이 되면 중요해진다.
1. Temporal Locality 시간적으로, 방금 들어온 명령을 또 쓸 가능성이 높다.= 방금의 명령을 기억해 놓으면 편하지 않을까?
2. Spcial Locality 공간적으로, 방금 명령이 들어온 부분에서 또 명령이 나올확률이 높다. = 방금 명령을 내린곳 근처의 명령도 기억하면 좋지 않을까?

캐시의 문제점.
캐시로 명령을 바꾼다고했을때, 이것은 메모리에 아직 들어가지 않은 수정사항이기에, 만약 멀티쓰레드 상황이라고 치면
1번쓰레드가 알고있는 정보와 2번쓰레드의 정보가 다를수 있다.

[ 메모리 배리어 ]
저번에 컴파일러 최적화로 인해 코드에 버그가 생긴것처럼, 하드웨어 최적화도 비슷한 것이 있다.
메모리도 각 코드간 별로 연관성이 없는것 같다고 판단한다면, 하드웨어(메모리)에서 사용하기 편하게 명령의 순서를 수정한다.
해결법 : 명령의 순서에 강제성을 추가한다. => 메모리 배리어

메모리 배리어의 용도?
1. 코드 재배치 억제 = 코드 중간에 MemoryBarrier()라는 선을 그어서, 이선을 넘어서까지 코드 재배치를 하진 말아라 하는것.
-> 데이터의 저장(Store)과 호출(Load)를 막는걸 Full Memory Barrier 라고한다. (ASM MFENCE, C# Thread.MemoryBarrier) , store만 load만 막는애들도 있는데 여까지는 잘안쓴다.

2. 가시성 = 저번 캐시때 말한것처럼, A의 캐시에 들어있는 정보를 B가 바로 볼수있게 하느냐를 말한다.
->가시성을 보장하기 위해서는 A가 캐시의 데이터를 메모리에 저장하고 B가 그것을 갱신하는 순서를 지켜줘야한다. (B는 업무를 보기전에 메모리를 commit받아온후 업무를 시작하면됨)

//어떻게보면 MemoryBarrier()는 이 위까지 한일을 메모리에다 커밋함과 동시에 그사이에 일어났을 다른 변화들을 커밋 받아온다 , 그후에 아래 일들을 수행한다고 볼수있다.
// 사실 이런걸 안쓰더라도 나중에 lock을 배우면 해결된다.

[ Interlocked ]
경합조건 (Race Condition) : 
식당예) 한 테이블에서 콜라1개를 주문했다. 이 주문은 주문현황판에 올라갔고, 현황판 본 점원 A B C는 전부 콜라를 갔다주어서, 결국에는 3개의 콜라를 갖다주게됬다.
=>이것을 경합조건 (Race Condition)이라 한다. 직원들이 차례 없이 막무가내로 일을 꺼내서 하다보니, 동시다발적으로 작업이 진행된 거임

원자성 : 더이상 쪼개서는 안되는 코드의 결합성, ex) 아이템을 산다면 : 골드-=100; 인벤 +=아이템; 로직일 것이다. 그런데 골드-=100 뒤에 서버가 다운된다면? 돈은 돈대로나가고 아이템은 들어오지 않을것임.
=> 즉, 골드의 감소와 동시에 아이템이 들어오는, 둘은 동시에 일어나야한다는 것이다.
or 아이템의 거래로도 원자성을 설명가능하다. A의 아이템이 사라짐과 동시에 B의 아이템이 추가되어야 한다. => 이게 문제가되면 아이템 복사, 증발이 일어나는것임
 
대표적인 코드예시가 number++; --;같은 녀석들임
이것을 방지하기위해 Interlocked 라는 문법을 통해, 코드를 원자화 시킬수있다. => 단 성능적 하락이 생기기 때문에 남용은 불가능
(Interlock 내부에는 메모리배리어도 포함되어 있기에, volatile같은 가시성 문제(순서문제)는 이제 신경쓰지 않아도 된다.)

그래서 위 식당문제같은경우, Interlocked를 사용하면, 가장먼저 명령을 접한애가 갖다주기를 한번에 완료해서, 중복된 수행이 사라짐

[ Lock 기초 ]
Interlocked가 좋기는한데, 정수만 넣을수있다는게 단점. 결국에는 코드를 Lock할수있는 방법도 알아야한다.
상호배제(Mutual Exclusive)=> Monitor.Enter(_obj); Monitior.Exit(_obj); =>간단히 말해, Lock의 문을 열고 닫는거임. 두 Monitor Enter와 Exit사이에 필요한 코드를 넣으면, 그 코드들은 원자성이 지켜짐.
(참고로 static object _obj = new object( ); 를 통해 Monitor의 인자를 넣어줘야한다. _obj가 별기능은 안한다는데, 아마 문을 잠글수있는 방을 만드는거라 생각하면 될듯?)

단점은, 섹션을 만들어 관리하는거다 보니, 관리가 조금 번거롭다. 만약 Monitor.Exit가 나오기전에 return이 나와버리면, 데드락(DeadLock)현상이 발생함. =잠금이 풀리지않아, 더이상 다른 코드가 돌질않음.
=> 이를 해결하기 위해 try catch문이나, lock(_obj) {}를 사용한다. //lock이 좀 괜찮아 보인다.

[ DeadLock ]
Interlock이나 lock같은 자물쇠를 걸어 원자성을 지킨다고 얘기했다. 이는 마치 화장실에 자물쇠를걸고 들어가서 다쓰고 자물쇠를 풀고나와, 다른사람이 들어갈수있게 하는것과 같다.
그런데 만약 자물쇠를 걸고 들어갔는데 나올때 자물쇠를 풀지않는다면 어떻게될까?( 실제 화장실은 아니니까 어떻게 나왔냐고 생각은 말자 )
=> 다음사람은 자물쇠가 걸려있기에, 더이상 들어갈수가 없다.
이게 lock이 하나뿐이면 쉬운데, lock이 여러개가 되면 관리하기 어려워진다. ->이경우 lock의 순서를 두는식으로 해결할수있다,
그런데 사실 deadlock을 예방하기가 힘든거지, 막상 발생하면 콜스택 추적을 통해 원인을 알기쉽다. 그래서 로직을 수정하는식으로 고치는 경우가 많다.
(그리고 완전 동시에 쓰레드가 시작되어서 서로 맞물리는게 아니면 deadlock이 잘안나기도한다. 그래서 실제상황에서는 쓰레드끼리 간격을 두고 작동하는경우가 많아서 잘 안나오긴함)

[ Lock 구현 이론 ]
화장실에 이미 사람이 있다면 어떻게 해야할까?
1. 끝날때까지 기다린다. =>시간 낭비가 있을수도있다.
2. 일단 자리로 갔다가, 나중에 다시 찾아온다. => 랜덤성이 강하다.( 자리로 가자마자 니올수도있고, 비운사이에 다른사람이 들어갈수도있고)
3. 자리 줄서기 대타를 구한다(난 자리에 있을테니 비면 와서 알려줘) => '나'는 편하지만 '대타'에게 부담이 감(만약 사람이 엄청 많다면 한명이 한번만 하면되는일을 자기가 100배 해야되니까)

1 = SpinLock 그자리에서 뺑뺑이 돌면서 락해제를 확인 (확인코드를 계속 돌려야되니 cpu점유율이 엄청 올라간다. 막 편한 일이아님)
2 = Thread가 소유권을 포기하고 나중에 다시 호출 (cpu가 짧게짧게 스레드를 돌린다고 했던것 기억나나? 그 할당된 시간이 끝나기전에 lock으로 인해 할일이 없다 판돤되면, 할당시간이 끝나기 전에 코어가 다른 쓰레드를 넘어가게 하는것임)
	//참고로 이렇게 cpu코어가 쓰레드를 넘나드는것도 부담이 많이 되는 행위다.
3 = 커널에 Event를 발생시켜달라는 코드를 짜고, 이를 감지하여 쓰레드 작동

[ SpinLock ]
멀티쓰레드 관련하여 굉장히 자주쓰는 기법
드물게, 두 쓰레드가 동시에 lock에 들어갈 수도 있어서 (정확히는 lock에 들어가서, 잠그기까지 그사이에 들어간것임 Acquire문을 보면 while로 lock체크를하고 그다음 코드로 lock을 거니까=이것도 원자성문제)

다시보면, 스핀락은 while문으로인해 무한히 반복하면서, Interlocked.Exchange와 리턴값의 if문 통해 _locked가 0에서1로 변하는 순간을 감지하여 lock을 여는것이라 할 수 있다. (잘보면 exchange는 무조건 _lock을 1로 바꾸는것인데, original이라는 리턴을 통해 0에서 1로 바뀌는 순간을 체크할수있음)
=> 0에서1로 변함을 감지하기 위해 CompareExchange를 사용할수도있다.(이걸 더 많이씀)

! 결국, 계속 while문을 돌면서(Spin) lock이 해제되어 있음을 확인한다면, interlock을 통해 확인과 동시에 잠금을 걸고, 용무를 보고, 잠금을 해제하는게 스핀락이다.

[ Context Switching ]
lock이 있으면, 자리로 돌아갔다가 다시 방문하는 랜덤메타.
사실 spinlock과 형태가 크게 다르진않음. Interlock.compareExchange해서 lock잠금 상태임을 확인했을때 어떻게 반응할것인지가 이 개념을 나누는 차이
스핀락은 곧바로 다시 compare해서 락상태를 확인하는 것이고, Context switching은 Thread.Sleeop , Yield 같은 여러 기능으로 쉬다오는것을 말한다

!Thread.Sleep(1); =>무조건 양보 = 인자ms만큼 무조건 쉬겠다. (사실 os의 스케쥴러가 정하는거라 완전한 1ms는 아님)
Sleep(0) =>조건부양보 = 나보다 우선순위가 낮은애들한테는 양보하지 않겠다. =>나보다 우선순위 높거나 같은애 없으면 다시 본인을 호출
Yield( ); => 관대한양보 = 지금 실행가능한 쓰레드가 있으면 실행해라 => 실행가능한 애가 없으면 남은 시간동안 그냥 본인 호출

!!하지만 중요한건, 이렇게 쓰레드를 휴식시키면서 소유권을 양도하는것이 무조건 좋은일이 아님.
앞서말해왔듯 cpu코어가 쓰레드를 전환할때는 굉장한 부하가 걸림.
이걸 자세히 설명하면, 쓰레드내에 필요한 정보는 굉장히 많고(ex. 지금상태, 하고있던작업, 기타등등) 그것을 담고있는 레지스터를 매번 RAM에 보관했다가(다른 쓰레드를 써야되니) 순서 확인할때 갖고오면 느리고 리소스도 많이 먹는다.
=>어떤 경우에는 그냥 스핀락으로 레지스터를 안지우는게 효율적일수도 있다는 말!

[ AutoResetEvent ]
커널에 Event를 발생시켜서, 가능할때 쓰레드에 알려주기. (직원이라는 제3자에게 자물쇠상태 확인 부탁 =< 나는 편하지만, 커널이 피곤)
말그대로 커널까지 가야하기에, 아까보다 컨텍스트 스위칭보다 더 느리다.

이제 Auto Reset Event 와 그 짝꿍격인 Manul Reset Event 두개를 알아보자
오토 리셋 이벤트의 개념은 고속도로 톨게이트와 같다. 
차가 한대 지나가면, 톨게이트가 자동으로 닫혀, 뒷차는 살짝 기다림. 
매뉴얼은 말그대로 수동, 문과 같다.
문을 닫지않으면, 직원이든 차든 무엇이든 몇개든 통과할 수 있다.

AutoResetEvent _available 을 만들고 WaitOne(), Set(), Reset()등의 명령어로 락을 열고 닫을수 있다. 
사실 waitOne을쓰면 열린락에 들어가서 잠그는 행위가 한방에 일어남. (reset이 락 닫는 코드인데 auto에서는 필요없더라)

매뉴얼 리셋 이벤트는 아까 말했듯 수동이다.
똑같이 ManualResetEvent _available 을 만들고 WaitOne(), Set(), Reset()등 명령어를 사용하면 되는데 
이번에는 수동이기에 waitOne으로 락을 확인해 들어간후 Reset으로 락을 잠가줘야한다. =>그런데 이러면, 확인 + 잠금 으로 다시한번 원자성에 위협이 생김
그렇다면 Manual리셋은 언제써야하는가? =락 안으로 여러개의 작업이 들어가야하는경우에 사용한다.

? Mutex ? 뮤텍스
위처럼 Lock클래스를 만들어서 Acquire Release를 만들고 이벤트를 통해 제어하는것 외에도, 커널에서 순서를 맞추는 방법이 있다.
기존에 Lock(우리가만든클래스) _lock을 만드는게 아닌 Mutex _lock =new Mutex();를 통해 만들고 사용하면 된다.
여기에는 이미 WaitOne, ReleaseMutex등이 구현되어 있다. 
=>편하긴한데, 커널을 이용하다 보니 느린편임
대신 얘는 더많은 정보들을 담을수있다, 예를 들면 지금까지 lock을 잠근횟수, thread ID를 통해 나를 잠근 쓰레드를 판별가능하고.. =>편하지만 리소스가 많이들겠다. 있다고만 알아둬라
, 또한 커널을 사용하는것이기에 다른프로그램들과의 동기화도 가능(근데 우린 게임이라는 하나의 프로그램을 쓰는거라 별로..)

[ ReaderWriterLock ] RWlock
<복습>
락 구현 = 뺑뺑이, 좀있다, 대리 =누가 더좋고 이런건아님. 애당초 라이브러리에서 여러 락을 혼합해서 사용함
lock명령문을 사용할수도 있고(내부적으로Monitor사용), spinlock명령문(얘도 제공되는게 있음, 그리고 얘는 뺑뺑이+좀있다 형태가 혼합됨 / 대신 try catch문을 써야된다.)을 써도 되고, Mutex를 쓸수도있다
왠만하면 lock쓰는것도 나쁘지않다.

경우에 따라서는 위 셋과 전부 다른형태의 lock이 필요할수도 있다.
예를들어, 거의 변동이 없는(그러나 있을수 있는) 데이터를 불러오는 함수가 있다쳐보자.
변동이 거의 없다해도 "만에하나 불러오는 도중에 데이터의 변화가 있을수 있기에" lock을 걸어주긴해야할것이다.
그런데, 이러한 만에하나를 위해서 lock을 걸어주는건 너무 비효율적이지 않을까?
=> 그럼 함수를 불러올때는 상관없지만, 변화가 있는 도중에는 다른곳에서 사용을 못하게 lock을 제한적으로 걸게할순 없을까? (일반적 경우에는 lock이 없다시피하다가, 특수한 경우에만 lock이 있듯이 작동)
== RWlock을 사용한다! (ReadWriterLockSLim이 최신버전임)

! 필요할때만 lock이 잠기는것처럼 할수있는 Reader Writer Lock

[ ReaderWriterLock 구현 ] =LockFree와 비슷 =어려움

_flag라는 32비트 int값을 사용하여 구현. 맨앞 1비트는 사용하지않고(Unused), 15비트는 WriteThread ID, ReadCount는 16비트로 이용한다.
해당 비트자리에 WriteMask, ReadMask를 씌워서 사용하게된다.

락을 만들때 정해야하는 정책
1. 재귀적 락을 허용할 것인가? (허용한다면, WriteLock->WriteLock (Ok) , WriteLock->ReadLock(Ok) , ReadLock->WriteLock (No) )
2. 스핀락 정책(락 접속실패시 어떻게 할것인가? 무한반복, 양보, //실습같은경우는 5000번 반복하고 양보)

사실 잘몰라도 이런걸 많이 쓰진않아서, 그때가서 다시 찾아보자.

[ Thread Local Storage ] TLS
쓰레드마다 고유하게 접근할 수 있는 전역변수

쓰레드에서 동시적으로 일을할때 전역 공간에 있는 데이터가 내 업무가 끝나기도 전에 변경되는 것을 막기위해 lock을 썼었다. 그러나 lock이 많아지면 그만큼 리소스 손실이 커짐.
그렇기에 TLS로 전역변수를 자기만 사용하는 공간으로 가져와서, 나(쓰레드)만이 사용할 수 있는 전역변수로써 사용하는것 


