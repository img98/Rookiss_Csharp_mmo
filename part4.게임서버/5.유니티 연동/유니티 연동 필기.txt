[ 유니티 연동 #1 ]
더이상 더미클라이언트가 아닌, 유니티 클라이언트로 서버와 연동을 해보자. (Server폴더 하위에 Client라는 유니티 프로젝트를 만들었다.)
서버코어의 dll파일을 유니티에 넣어주면, 유니티에서도 서버코어에서 만든 기능들을 참조해 사용할 수 있다. (그런데 실제로 할때는 그냥 스크립트 복붙으로했다.dll로 바로옮기면 안되는부분 체크가 힘들어서 그렇다네)
그러나 문법이나 정책이 좀 다르기에, 그대로 갖다쓸수는 없고, 안되는건 조금씩 수정해줘야함.
(서버에서 사용하는 JobQueue, Listener, PriorityQueue는 삭제해줬다.)

//잠깐 이상한것 : 그동안만든 c#파일들을 유니티 프젝에 옮겨줬는데, 강사말로는 Span계열이 에러가 난다고한다. 그런데 내꺼에서는 문법 밑줄이 안쳐진다...(버전 차이인가?)
아무튼 못쓴다고 가정하고,

Span을 사용할수 없으니, Read에선 Slice대신 예전처럼 배열과, 시작점을 가져다가 호출하는식으로 해줬고,
Write에선 TryWriteBytes를 쓸수없으니(이건 좀 심각) 매번 GetBytes로 바이트배열을 만들고 Array.Copy로 넣어줄수도있고, unsafe코드로 포인터를 사용하는방법도있다(이건 c++이랑 비슷).

[ 유니티 연동 #2 ]
유니티에서는 메인쓰레드가 아닌, 다른 쓰레드에서 게임과 관련된 부분에 접근하는걸 차단한다. 그래서 PacketHandler.cs에서 게임오브젝트를 찾아내는 코드를 짜도, 반응하지 않았음.
//즉, 서버에서 보낸 정보를 받아서 디버그로 출력은했어도(백그라운드 쓰레드는 정상적으로 작동함), 게임에 있는 정보(오브젝트)를 찾아내는(접근하는)걸 할수없었음.
그러므로, 이런 외부 기능들을 유니티쪽 메인게임쓰레드에서 호출하도록 구조를 바꿔줘야한다.
(앞서만든 기능들을 큐에 담아서, 후에 유니티의 쓰레드가 처리할수있도록 해줘야함)

이렇게 만든 큐를 어디서 밀어넣고, 빼도록 처리해야할까? => ClientPacketManager에서 처리

//Func : delegate이긴한데, 형태가 이미 정의된 delegate다. out으로 TResult를 받을수있음.

그래서 큐에 밀어넣고 빼도록 처리하는 ClientPacketManager를 컴포넌트(MonoBehaviour)인 NetworkManager의 Update문에서 호출하면,
!유니티의 메인쓰레드가 그 Update문을 돌릴것이고, 메인쓰레드가 ClientPacketManager를 호출해서, 메인쓰레드가 패킷매니저의 큐에있는 업무(오브젝트찾기)를 할 수 있는 것이다.

[ 유니티 연동 #3 ]
이제 단순한 채팅만이 아닌, 패킷을 이용해 유니티 오브젝트들을 이동시키거나 생성시켜보자.
주로 유니티에서 사용할 패킷의 구조와, 패킷자동형성 코드 세부수정을 했다.

[ 유니티 연동 #4 ]
캐릭터들의 위치이동의 연동이 정말 어려운거다.
이걸 구현하는 방법이 여러가지가 있는데, 일단 우리는 서버에서 ok사인이 떨어지면 움직이도록 할것이다. (일단 움직이고, 서버의 사인에 따라 세부조정하는 방법도 있다고한다.=이게 캐릭 순간이동의 이유인듯?)
