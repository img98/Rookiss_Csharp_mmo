[ 채팅 테스트 #1 ]
패킷과 세션, 네트워크가 준비되었으니 컨텐츠를 제작할 대략적인 준비는 끝났다. 그런데 이걸 어떻게 다뤄야될지가 막막할거다.
한번 채팅서버를 구현해보며 응용법과 문제점을 알아보자. (채팅 = 같은방안에 있는 모두에게 가변데이터를 뿌림 => 게임과 동일)

[ 채팅 테스트 #2 ]
지금 더미클라의 용도는 수많은 더미클라를 만들어보는것이니, 여기도 세션매니저를 일단 만들어보자.(실제 런칭상황에서는 필요없을것임)

서버는 한유저가 보낸 패킷채트를, 해당 게임룸의 유저수만큼 복사해서 뿌려야하기에, 내가 한마디해도 듣는사람이 수십만명이면 서버는 수십만마디를 해야된다는 뜻
(그래서 유저가 많은곳에서는 서버렉이 생기는것) 그렇기에 브로드캐스팅(서버가 유저에게 채팅전달)에는 규칙을 정해야함. 브로드캐스팅의 범위를 정한다는 식으로.

만약 지금 구현한것처럼 브로드캐스팅에서 한세션의 말을, 모든 세션들에게 보내는, 한동작마다 락을 잡아주면,
수백의 세션이 말을한다고 할때 쓰레드가 여기 몰려서 계속 패킷이 밀리게 되고, 패킷이 밀리니 새로운 쓰레드를 생성해서 더욱 몰리게 되는 악순환이 생긴다.
=> 이걸 해결하는 방법이, GameRoom은 하나만 만들고, 여기서 lock없이 혼자 처리하게 하는것이다.
그러면 전달받은 패킷들은 처리할때까지 기다리느냐? 아니다. 혼자일하는애한테, 끝나고 이거하라고 큐에다가 업무를 남겨놓고 가면된다. (=> 이게 바로 Job Queue인듯?)

[ Command 패턴 ]
Job, Task 큐가 이 커맨드패턴을 의 개념을 사용하기에 알아보자.
가게의 예로 돌아가보자. 세션(대리인)이 식당에게 주문을 하게될건데, 우리가 지금까지 구현한 코드는 주문을 받으러온 일꾼(스레드)가 주문을 받고, 직접 주방에가서 요리까지하고, 전달까지 하는 방식이였다.
근데 주문이 너무나 많아지면, 주방에 여러명이 들어오거나 주방이 빌때까지 기다리게되고 이건 비효율적이란걸 알수있다. -> 즉, 아까말한 쓰레드가 몰리는 악순환이 이거다.
주방은 주방의 업무를 보는 주방장을 두고, 서빙만하는 직원을 두는식으로 전달자와 실행자를 두면좋겠다.

커맨드패턴 : 직접 일처리까지 하는것이 아닌, 일처리 담당자에게 하라고 명령을 전달만 하는 패턴. (지금의 주문을 나중에 처리할수있게 주문서를 전달)
이패턴의 강점이, 주문을 만드는 순간과, 명령을 수행하는 부분을 나눌수있다는 것이다. (락을 걸기 용이해질듯)

[ JobQueue #1 ]
서버코어에 JobQueue를 만들어주자(여기저기서 잡큐를 쓸거니 코어에 만들었다.)
지금의 잡큐는 그저 잡(업무)들이 들어있는 큐다. 이걸 GameRoom에 적용해보자. 그냥 게임룸내에 잡큐라는 큐를만들고, 여기다가 Action이라는 delegate들로 명령을 밀어넣으면됨.

이제 중요한건, 그렇게 밀어넣은 잡큐를 누가 수행할지다. 이건 본인이 선택해서 설계하면됨
그런데 이 형태는 예전에 ServerCore를 만들때, Send와 RegisterSend를 따로 만드는식으로 했던 형태와 비슷하다.
Send에서 만약 예약된게 없고 처음이면, 바로 업무를 실행하는 코드를 호출했고, 예약된게 있다면, RegisterSend로 보내 예약을 했었다.

이번강의 특이포인트! 람다를 통해 잡큐에 업무를 넣는다. 그런데 이것은 예약서를 남기는 거기에, 실행과 예약 사이에는 텀이 생기고,
그 텀사이에 참조값이 null이 되버리면 에러가발생함. 이를 어떻게 해결해야할까? => 참조값을 복사해서 사용하게한다!
 if(Room!=null) {
GameRoom room = Room;//잡큐로 인해, Room=null이후에 leave가 일어남. 그러면 Room.leave는 null.leave가 되어버려 에러가 발생. 이걸막기위해 Room을 복사한 room을 통해 leave를 호출해야한다. 
room.Push(() => room.Leave(this)); //클라이언트의Room은 null이 됬지만, room은 계속 이전의Room을 참조할수있기에, 이러한 코드가 가능해진다.
Room = null; }

[ JobQueue #2 ]
지금까지 잡큐를, 잡을 푸쉬해주고 한명만 순차적으로 수행하는 개념이라 했는데, 이것말고도 수동으로 이걸처리하는 경우도 있다?

앞서했던것처럼 잡을 대충 action으로 정의해서, 람다식으로 큐에다 넣는것이 아니라,
잡을 클래스로 직접 설계한뒤 사용하는 것이다. (수업에서는 ITask라는 인터페이스를 상속받는 Task들을로 만듬. 별거아님 걍 잡을 Task라는 이름으로 썻다이말.)
그렇게 만든 Task들을 담는 큐를 만들고, 전시간에 했던것처럼 잡큐돌리듯 큐를 돌리는것이다.

즉, 두방법의 차이점은, 예약서를 람다로 만드느냐, 클래스로 만드느냐 차이
두방법의 공통점이자 핵심은, 어쨋든 받은 요청을 일감(잡,Task)라는 단위로 바꿔서, 큐에 담아 나중에 실행하게 했던것!!

이제 두번째로 생각해야 될것은, 이렇게 만들어낸 잡큐를 누가 들고있을거냐는 것이다.
바람의나라 같은경우에는 각 맵마다 한장한장 구역이 있어서, 그 구역이 들고있게 하면됬다.
그러나 와우같은 심리스 게임은 누가 들고있어야할지 구분하기가 매우 애매하다. 하나의 넓은 맵에 영역을 구분할수가 없음.
=> 이 경우, 잡큐를 존마다 넣는게 아니라, 모든 사물에 달아두는 방법도 있다. (지금은 심리스 게임을 만들게 아니라, 일단 이해하려들지마라)

[ 패킷 모아보내기 ]
던전이라거나 마을같은, 혹은 필드존같은 게임Room에 많은 유저들이 존재할것이고, 그 Room안에서의 행동들을 Room안의 유저들에게 뿌려주는 작업을 하는게 온라인게임이다.
지금은 Chat만 구현했지만, 이걸 이동, 공격같은 패킷으로 바꾸면, 받은 패킷들을 모두에게 뿌림으로써 서로 같은공간에 존재하는것처럼 보이게 할 수 있다. =>시간을 서버랑 연동시키면 그럴싸하게 보일거임

그러나 지난 시간에, 한동작마다 모든 유저에게 실시간으로 패킷을 뿌리는건 부담이 된다고했다. 
이걸 해결하기 위한 방법이 '패킷 모아보내기'이다. //예전에 sendBuffer를 일정량 모은다음에 보낸거랑 비슷한 개념인듯?
이것은 엔진측에서도 할수있고(큐에 밀어넣을때, 일정량 모이면 보내는 작업을 호출), 컨텐츠(=게임룸)에서도 할수있다.
지금은 컨텐츠 측에서 모아보내는방법을 해보겠다. (간단하다)
=> 그냥 룸에서 리스트에 행동패킷들을 모아놨다가, 일정량 모이면 보내는거임.

Server에서 만든 GameRoom에 _pendingList라는 패킷을 모아놓는 리스트를 만들고, Server의 메인쓰레드인 Program.cs의 main함수에서 while문으로 0.25초마다 리스트를 뿌리는 식으로 구현했다.

[ Job Timer ]
지금은 하나의 룸만 있으니, 메인서버에서 while을 돌리는데 sleep으로 시간조절을 했지만, 룸이 여러개가 되면 상황이 달라질것이다.
(누구는 0.25초마다 누구는 0.1초마다 갱신이 필요할 수도 있으니)
어떤식으로 시간관리를 할지 결정을 해야함.
1. 틱을 사용해 하는방법이 있다. 매 룸마다 기준틱을 만들어주고, while문을 계속돌리면서 틱이 일정시간 이상 지나면 실행되게 if문사용
(하지만 틱간격이 엄청 큰경우(ex.10초)에도 while문이 돌아갈때마다 계속 비교를 해줘야하니 비효율적일수 있다.)
2. Coroutine처럼 시간타이머를 만들어 쓰면좋겠다. //우선순위 큐를 사용한다.

JobTimer라는 시간을 따로 체크해서 관리하는 중앙관리자가 있으면 각각 다른 시간마다 처리되어야 하는 기능들의 수행에 큰 도움이 된다.