[ Serialization #1 ]
Serialization = 직렬화 = ex) 패킷이라는 객체를 네트워크에 보내기 위해, 바이트 배열에 밀어넣었다.
이런식으로 인스턴스를 납작하게 만들어 버퍼안에 밀어넣는 것이 직렬화 이다.
//반대로 OnRecvPacket마냥 직렬화되어 들어온 패킷버퍼를 다시 해체해서 정보를 까보는, 원래형태로 돌리는 것을 Deserialization(역직렬화)이라한다.

직렬화라는게 네트워크 통신뿐 아니라, 게임 세이브파일에도 사용가능. 아이템, 레벨, 등등 여러 정보들을 바이트 배열에 담아 파일로 저장할때 사용함.

// 배열이 [ ][ ][ ]...[ ][ ] 이런식으로 1자로 길게줄지어 있으니, 이걸 채우는걸 직렬화라 하는듯하다.

시작에 앞서, 클라프로그램과 서버프로그램에 있던 각 세션들을 클라에는 서버세션으로, 서버에는 클라세션이라는 이름으로 보냈다. (세션이라는게 결국 대리자(식당 대리인)의 개념이기에, 클라쪽에 서버세션이 있는게 맞다.)

패킷 파싱단계에서 전에는 BitConverter.GetBytes를 통해 각각의 바이트를 알아와 새로운 임시버퍼를 만들고, 이것을 전달할 버퍼(s)에 담는것으로 안정적이게 전달버퍼를 만들수 있었다. 하지만 안전을 추구하다보니 리소스손실이 있음(새로운 임시버퍼를 만들어야하는것)
한번에 전달버퍼에 패킷내용을 담을수 없을까? => 여러방법이 있는데, 그중 하나로 TryWriteBytes를 사용하자!

[ Serialization #2 ]
지난번에 TryWriteBytes 패킷을 만들어 버퍼에 밀어넣는 방법과, Recv에서 버퍼에 있는걸 열어보는 역직렬화를 해봤다.
오늘은 Packet클래스에 abstract를 read write를 만들어, 각 타입의 패킷이, 자기 스타일에 맞는 return을 할수있게 만들었다. (연습에서는 애초에 infoReq만을 예시로했기에, 지난번 내용을 옮기는 위주였다.)

패킷 Read에서 악의적으로 사이즈를 속여 보내는 경우, 필요한 데이터를 읽지 못할수도 있다. 이걸 방지하기위해 필요데이터(playerId)를 파싱할때 범위에 span을 사용하여 입력하면
이 범위를 초과하는 파싱을 하려할때 에러를 발생시킨다. => 에러는 우리의 설계구조상 catch exception 을 하게되어 무엇이 문젠지 찾아낼수다.

결론적으로 오늘은 serialize, deserialize를 개선했다.

[ UTF-8 vs UTF-16 ]
리스트나 문자열 같은 가변적인 크기를 가진 패킷을 serializtion하는 방법을 배울 예정인데,
이를 배우기 이전에 '유니코드와 인코딩'에 대한 내용을 알아볼 것이다.

인코딩 = 문자를 컴퓨터에게 어떻게 이해시킬지에 관한 부분.
유니코드 = 온세상의 문자들을 통일된 규격으로 만드는 작업을 진행함.(아스키코드 같은건데, 언어에 2바이트, 즉 6만개가 넘는 숫자중 하나를 할당해줌(a=31이런게 아스키고 이게 스케일이 커졌다고 생각하면됨))
(사실 언어량이 워낙많다보니 3바이트 범위까지 넘어감)
어쨋든 이러한 3바이트 코드를 어떻게 컴퓨터에게 이해시킬지가 오늘의 주제임

첫번째 방법 : A = 0x000041마냥 3바이트 코드를 넘겨줌 =>비효율적이다. 분명 잘안쓰는 글자도 있을텐데, 걔네 때문에 자주쓰이는 A를 쓰려면 매번 3바이트씩 사용해야됨
이런 비효율을 잡기위해 나온것이 UTF-8과16이다.

UTF-8은 영문(알파벳)의 경우는 그냥 1바이트만 사용해서 전송한다. 그리고 한글은 3바이트를 사용한다. //그래서 외국겜에 utf-8을쓰면 효과적이지만, 한글이 많이 나오는 한국겜에 utf-8을 사용하면 비효율적일것이다.
UTF-16은 2바이트로 보낼수있는 문자들은 전부 2바이트로 보낸다. 이범위를 초과해서 3바이트가 필요한애들은, 4바이트로 표기한다. //영문도 2바이트, 한글도 2바이트라서, 영어권에게는 손해겠지만 일반적으로는 이득일것

지금까지 1바이트 1바이트를 아끼기 위해 패킷구조를 사용한건데, 얘네는 문자를 어떻게 인코딩하느냐에따라 바로 바이트가 2배로 뛰거나 감소한다.
그래서 런칭할때 이런 언어 선택을 잘 생각해야됨.

[ Serialization #3 ]
수업이 들어가기 전에 TryWriteBytes에서 매번 new Span...하드코딩이 보기싫기도하고, 더 효율적이기도한 slice를 사용하여 코드를 개선하겠다.
slice는 span의 기능중 하나로, 말그대로 span을 토막내서 일정부분을 추출하는것임. 단 실질적으로 s에 변화가 있는건 아니고, slice해서 새로운 복제품을 추출하는것 // Slice(시작위치, 길이)

오늘은 고정된 사이즈가 아닌, string같이 가변적인 크기의 데이터를 어떻게 보내고, 추출할지에 대한 내용을 해볼것이다.
! =>string을 보낼때, 그앞에 헤더로 string의 길이를 2바이트로 보내 그 가변적인 크기는 얼마인지 알려주고, 그뒤에 string 데이터를 보내면 해결되겠다.
그럼 문자데이터의 바이트를 구하려면 어떻게 해야할까? => Encoding.Unicode.GetByteCount(this.name) 을쓰면됨

다음시간에는 List는 어떻게보내는지 알아보자.

[ Serialization #4 ]
List도 경우에 따라 다르다. List<int>와 같이 간단하면, string때처럼 리스트의 크기를 먼저보내주고 뒤에 리스트를 보내주면된다.
하지만 List안에 구조체가 들어있다면 어떨까? 사실 이것도 비슷하다. 리스트란게 결국 여러개의 데이터를 들고있다는 것이니, 몇개 들고있는지를 short로 넣어주고, 데이터를 밀어넣는다.

포폴용이면 수업에서 만든 것처럼 skillinfo의 read write를 일일이 만들어줘도 된다. 그렇지만 당연히 반복작업이 많다보니 시간소요도 길고 실수할지도모름
(자동화 하는것도 시간이 좀 걸리니, 알아서 잘판단해라)

지금까지 우린 아래와 같이 직접 패킷을 만들어서 보냈다.
            PlayerInfoReq packet = new PlayerInfoReq() { playerId = 1001, name = "ABCD" };
            packet.skills.Add(new PlayerInfoReq.SkillInfo() { id = 101, duration = 3.0f, level = 1 });
하지만 경우에 따라, 입력을 받자마자 바로 바이트배열에 넣어줄수도있다.
일반적으로 이런 serialization을 할때, 구글의 protobuf나 Flatbuffers를 자주 사용한다.

Protobuf가 지금과 비슷하게, 중간에 인스턴스를 만들어 입력을 넣고, 그걸 변환시키는 작업을 거치고
Flatbuffers가 위에 말한것처럼 데이터를 바로 바이트배열에 넣는 방법이다.

Protobuf가 성능적으로 손해를 볼 순 있지만, 코딩짜기 쉽고 직관적임.

[ Packet Generator #1 ]
자동화를 구현하려면, 지금까지 했던것처럼 일단 하드코딩으로 만들어보고, 반복되는 부분을 재사용코드로 빼주면된다.

일단 패킷에 대한 정의를 PacketGenerator라는 프로젝트를 새로 만들어 빼줄거임. 거기서 PDL(Packet Definition List)이라는 xml 파일을 만들어줄거다
xml의 형식은 그냥 이해하려하지말고 따라써라. 쓰다보면 익숙해진다고한다.(진짜 이해되네) <타입 name="">로 열어주고, </타입>으로 닫아준다.
아무튼 이것을 통해, 우리가 지금껏 만든 클래스의 형태를 표현할 수 있다.
//PacketGenerator에 xml을 사용하는 문법 엄청쓰는데, 무슨 생전처음보는걸 설명도안하고 그냥 이런거다 하고 넘어가네

패킷의 자동화를 할때 유용한방법 = 패킷포맷을 정의하고, 안에있는 부분을 갈아끼우는 식으로 만들면된다. 
고정된 부분은 냅두고, 반복되는 부분은 제거
제거하고 채워넣어야 될부분에 {0} {1}이런식으로 표시할건데, 원래의 {}랑 헷갈릴수있으니, 원본은 {{ }}이런식으로 표기하자 => 헷갈려서가 아니다, 이렇게 해줘야 인식이 되더라
=> 어떻게 채워야할지에 대한 템플릿을 만든것.

[ Packet Generator #2 ]
결국 하고싶은게 뭐냐. PacketGenerator에서 패킷의 이름을 하나하나 꺼낼수 있으니, 그걸 이용해 xml의 {0} {1} 이런걸 채우는것





