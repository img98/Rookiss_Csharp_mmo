[ Serialization #1 ]
Serialization = 직렬화 = ex) 패킷이라는 객체를 네트워크에 보내기 위해, 바이트 배열에 밀어넣었다.
이런식으로 인스턴스를 납작하게 만들어 버퍼안에 밀어넣는 것이 직렬화 이다.
//반대로 OnRecvPacket마냥 직렬화되어 들어온 패킷버퍼를 다시 해체해서 정보를 까보는, 원래형태로 돌리는 것을 Deserialization(역직렬화)이라한다.

직렬화라는게 네트워크 통신뿐 아니라, 게임 세이브파일에도 사용가능. 아이템, 레벨, 등등 여러 정보들을 바이트 배열에 담아 파일로 저장할때 사용함.

// 배열이 [ ][ ][ ]...[ ][ ] 이런식으로 1자로 길게줄지어 있으니, 이걸 채우는걸 직렬화라 하는듯하다.

시작에 앞서, 클라프로그램과 서버프로그램에 있던 각 세션들을 클라에는 서버세션으로, 서버에는 클라세션이라는 이름으로 보냈다. (세션이라는게 결국 대리자(식당 대리인)의 개념이기에, 클라쪽에 서버세션이 있는게 맞다.)

패킷 파싱단계에서 전에는 BitConverter.GetBytes를 통해 각각의 바이트를 알아와 새로운 임시버퍼를 만들고, 이것을 전달할 버퍼(s)에 담는것으로 안정적이게 전달버퍼를 만들수 있었다. 하지만 안전을 추구하다보니 리소스손실이 있음(새로운 임시버퍼를 만들어야하는것)
한번에 전달버퍼에 패킷내용을 담을수 없을까? => 여러방법이 있는데, 그중 하나로 TryWriteBytes를 사용하자!

[ Serialization #2 ]
지난번에 TryWriteBytes 패킷을 만들어 버퍼에 밀어넣는 방법과, Recv에서 버퍼에 있는걸 열어보는 역직렬화를 해봤다.
오늘은 Packet클래스에 abstract를 read write를 만들어, 각 타입의 패킷이, 자기 스타일에 맞는 return을 할수있게 만들었다. (연습에서는 애초에 infoReq만을 예시로했기에, 지난번 내용을 옮기는 위주였다.)

패킷 Read에서 악의적으로 사이즈를 속여 보내는 경우, 필요한 데이터를 읽지 못할수도 있다. 이걸 방지하기위해 필요데이터(playerId)를 파싱할때 범위에 span을 사용하여 입력하면
이 범위를 초과하는 파싱을 하려할때 에러를 발생시킨다. => 에러는 우리의 설계구조상 catch exception 을 하게되어 무엇이 문젠지 찾아낼수다.

결론적으로 오늘은 serialize, deserialize를 개선했다.

[ UTF-8 vs UTF-16 ]
리스트나 문자열 같은 가변적인 크기를 가진 패킷을 serializtion하는 방법을 배울 예정인데,
이를 배우기 이전에 '유니코드와 인코딩'에 대한 내용을 알아볼 것이다.

인코딩 = 문자를 컴퓨터에게 어떻게 이해시킬지에 관한 부분.
유니코드 = 온세상의 문자들을 통일된 규격으로 만드는 작업을 진행함.(아스키코드 같은건데, 언어에 2바이트, 즉 6만개가 넘는 숫자중 하나를 할당해줌(a=31이런게 아스키고 이게 스케일이 커졌다고 생각하면됨))
(사실 언어량이 워낙많다보니 3바이트 범위까지 넘어감)
어쨋든 이러한 3바이트 코드를 어떻게 컴퓨터에게 이해시킬지가 오늘의 주제임

첫번째 방법 : A = 0x000041마냥 3바이트 코드를 넘겨줌 =>비효율적이다. 분명 잘안쓰는 글자도 있을텐데, 걔네 때문에 자주쓰이는 A를 쓰려면 매번 3바이트씩 사용해야됨
이런 비효율을 잡기위해 나온것이 UTF-8과16이다.

UTF-8은 영문(알파벳)의 경우는 그냥 1바이트만 사용해서 전송한다. 그리고 한글은 3바이트를 사용한다. //그래서 외국겜에 utf-8을쓰면 효과적이지만, 한글이 많이 나오는 한국겜에 utf-8을 사용하면 비효율적일것이다.
UTF-16은 2바이트로 보낼수있는 문자들은 전부 2바이트로 보낸다. 이범위를 초과해서 3바이트가 필요한애들은, 4바이트로 표기한다. //영문도 2바이트, 한글도 2바이트라서, 영어권에게는 손해겠지만 일반적으로는 이득일것

지금까지 1바이트 1바이트를 아끼기 위해 패킷구조를 사용한건데, 얘네는 문자를 어떻게 인코딩하느냐에따라 바로 바이트가 2배로 뛰거나 감소한다.
그래서 런칭할때 이런 언어 선택을 잘 생각해야됨.

[ Serialization #3 ]
수업이 들어가기 전에 TryWriteBytes에서 매번 new Span...하드코딩이 보기싫기도하고, 더 효율적이기도한 slice를 사용하여 코드를 개선하겠다.
slice는 span의 기능중 하나로, 말그대로 span을 토막내서 일정부분을 추출하는것임. 단 실질적으로 s에 변화가 있는건 아니고, slice해서 새로운 복제품을 추출하는것 // Slice(시작위치, 길이)

오늘은 고정된 사이즈가 아닌, string같이 가변적인 크기의 데이터를 어떻게 보내고, 추출할지에 대한 내용을 해볼것이다.
! =>string을 보낼때, 그앞에 헤더로 string의 길이를 2바이트로 보내 그 가변적인 크기는 얼마인지 알려주고, 그뒤에 string 데이터를 보내면 해결되겠다.
그럼 문자데이터의 바이트를 구하려면 어떻게 해야할까? => Encoding.Unicode.GetByteCount(this.name) 을쓰면됨

다음시간에는 List는 어떻게보내는지 알아보자.

[ Serialization #4 ]
List도 경우에 따라 다르다. List<int>와 같이 간단하면, string때처럼 리스트의 크기를 먼저보내주고 뒤에 리스트를 보내주면된다.
하지만 List안에 구조체가 들어있다면 어떨까? 사실 이것도 비슷하다. 리스트란게 결국 여러개의 데이터를 들고있다는 것이니, 몇개 들고있는지를 short로 넣어주고, 데이터를 밀어넣는다.

포폴용이면 수업에서 만든 것처럼 skillinfo의 read write를 일일이 만들어줘도 된다. 그렇지만 당연히 반복작업이 많다보니 시간소요도 길고 실수할지도모름
(자동화 하는것도 시간이 좀 걸리니, 알아서 잘판단해라)

지금까지 우린 아래와 같이 직접 패킷을 만들어서 보냈다.
            PlayerInfoReq packet = new PlayerInfoReq() { playerId = 1001, name = "ABCD" };
            packet.skills.Add(new PlayerInfoReq.SkillInfo() { id = 101, duration = 3.0f, level = 1 });
하지만 경우에 따라, 입력을 받자마자 바로 바이트배열에 넣어줄수도있다.
일반적으로 이런 serialization을 할때, 구글의 protobuf나 Flatbuffers를 자주 사용한다.

Protobuf가 지금과 비슷하게, 중간에 인스턴스를 만들어 입력을 넣고, 그걸 변환시키는 작업을 거치고
Flatbuffers가 위에 말한것처럼 데이터를 바로 바이트배열에 넣는 방법이다.

Protobuf가 성능적으로 손해를 볼 순 있지만, 코딩짜기 쉽고 직관적임.

[ Packet Generator #1 ]
자동화를 구현하려면, 지금까지 했던것처럼 일단 하드코딩으로 만들어보고, 반복되는 부분을 재사용코드로 빼주면된다.

일단 패킷에 대한 정의를 PacketGenerator라는 프로젝트를 새로 만들어 빼줄거임. 거기서 PDL(Packet Definition List)이라는 xml 파일을 만들어줄거다
xml의 형식은 그냥 이해하려하지말고 따라써라. 쓰다보면 익숙해진다고한다.(진짜 이해되네) <타입 name="">로 열어주고, </타입>으로 닫아준다.
아무튼 이것을 통해, 우리가 지금껏 만든 클래스의 형태를 표현할 수 있다.
//PacketGenerator에 xml을 사용하는 문법 엄청쓰는데, 무슨 생전처음보는걸 설명도안하고 그냥 이런거다 하고 넘어가네

패킷의 자동화를 할때 유용한방법 = 패킷포맷을 정의하고, 안에있는 부분을 갈아끼우는 식으로 만들면된다. 
고정된 부분은 냅두고, 반복되는 부분은 제거
제거하고 채워넣어야 될부분에 {0} {1}이런식으로 표시할건데, 원래의 {}랑 헷갈릴수있으니, 원본은 {{ }}이런식으로 표기하자 => 헷갈려서가 아니다, 이렇게 해줘야 인식이 되더라
=> 어떻게 채워야할지에 대한 템플릿을 만든것.

[ Packet Generator #2 ]
결국 하고싶은게 뭐냐. PacketGenerator에서 패킷의 이름을 하나하나 꺼낼수 있으니, 그걸 이용해 xml의 {0} {1} 이런걸 채우는것

[ Packet Generator #3 ] !이거 히트네
애초에 바이트배열을 보내는 코드도 추가하자.
애초에 바이트이니 BitConverter를 쓸필요없고, 그냥 배열로 넣어주면됨. 방식은 앞서했던것과 같다.

이렇게 패킷포맷을 구조적으로 잘 만들었으면 후에 추가상황이 생겨도 잘 맞아돌아감.
ex) 리스트내의 리스트를 또 만들고싶어서, PDL에 list내부에 새로운 list를 넣었다. 그리고 바로 실행했는데, 알아서 잘돌아가더라.

?이상한점 : packetFormat.cs의 packetFormat을 보면 마지막 write후에 }}로 끝낼때 }}"; 이런식으로 끝내면 마지막 괄호 안나오던데 왜인지모르겠다? 꼭 줄바꿈을 해줘야 제대로 찍힌다.
그런데 또 이상한게 패킷 두개만들어서, 아래 test패킷은 끝까지 괄호 잘나오더라, 위처럼 줄바꿈안해줘도.

[ Packet Generator #4 ]
지금까지 만들어온 패킷제너레이터는 성공적으로 완성했다. 그런데 이렇게 형성한 패킷구조를 수동으로 서버세션이랑 클라세션에 복붙해 알아먹게 하는게 너무 귀찮다.(사실 이걸 막으려고 제너레이터를 만든거기도하고)
=> 각 프로젝트에 Packet이란 폴더를 만들고, 거기다가 GenPackets를 생성하게 하면된다. (폴더를 만든 이유는, 그냥 우리가 만든거라고 시각적으로 보기좋게 하려는 이유)

프로젝트 - 속성 -빌드 를 통해 빌드시 파일이 생성될 위치를 조정가능.(이걸로 PDL.xml을 귀찮게 bin-dubug까지 가서 복붙해주지 않아도된다.)
csproj파일에 가서 <AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath> 를 추가해주면 netcoreapp3.1폴더 하에 빌드가 만들어지는걸 없앨수 있다.

그리고 xml파일을 찾을때 경로를, string pdlPath = "../PDL.xml"; 로 넣어주면 ../이 뒤로 한폴더 나가라는 뜻이니, bin의 밖에 있는 PDL.xml을 찾을수있다.

이제 목표는 PacketGenerator프로젝트를 실행시키면, 각 더미클라이언트, 서버 프로젝트의 Packet의 GenPackets.cs가 갱신되게 바꿔주면 된다.
-> 방법은 다양한데, bat파일을 만들어서 해주는게 편하고 많이들쓴다. (배치파일은 windows에서 사용할수 있는 기능들을 자동으로 쓰게해주는데, 필요할때마다 구글링해서 써라)
->우리의 목표는 PacketGenerator의 exe파일을 자동으로 누르게하는것

배치파일에 START ../../PacketGenerator/bin/PacketGenerator.exe ../../PacketGenerator/PDL.xml 라고 써주면됨.
이러면 ../../PacketGenerator/bin/PacketGenerator.exe로 프로젝트를 실행하고
프로젝트의 Main에 ../../PacketGenerator/PDL.xml 라는 첫인자를 넣어준(args에 [0]을 넣어준) 것이다.

이제 남은건 위 bat파일을 통해 만들어진 GenPackets.cs를 (bat파일이 있는곳에 만들어짐) 더미클라와 서버의 packet폴더로 보내는 것이다.
이것도 찾아보면 bat에 XCOPY라는 명령어가 있으니 그걸쓰면된다.

!위 과정이 굉장히 간단하면서도 효과적이였다. 이제 여러가지 작업을 한 후에, bat파일을 누르는것만으로 다른 프로젝트에도 복사해줄수있다.
혹은 코드내에서 bat파일을 실행시켜서, 빌드과정에서 바로 복사시킬수도있다.

[ Packet Generator #5 ]
성능적인 개선을 해보자.
ClientSession을 보면 case문에서 패킷id에따라 행동을 실행한다. 그런데 필요한 case문의 순서가 199번째에 있다면?  쓸모없는 198번의 비교를 할 수도 있다. 이런 낭비를 줄여보자
모든 패킷의 부모되는 IPacket이라는 인터페이스를 만들어서 ushort Protocol 을 보내줌. (이게뭔데? = 패킷id를 보냄)
그리고 PacketHandler를 만들어서, switch문에서 모든 case와 비교하는게 아니라, 핸들러cs파일에 있는 해당 함수를 한번 호출하게 하는것임(아까 Protocol로 보낸 패킷id를 보고)
그리고 PacketManager에는 전달된 패킷을 읽는 기능을 넣을것이다. 그래서 Manager로 읽고, Handler로 처리하는것임. //결국 clientSession.cs에 OnRecvPacket의 내용을 옮긴것

이렇게 만든 자동으로 패킷을 등록하고 호출할수있도록 만든 PacketManager도 PacketGenerator에서 자동으로 생성되게 해주면,
PDL에 새로 추가해도, PacketHandler에서 그걸 처리할 함수(action)만 만들면 된다.

[ Packet Generator #6 ]
자동화를 해줄건데, 파일 크기가 크지않으니, GenPacket에 껴넣지말고 새로운 파일을 만들겠다. (물론 PacketFormat.cs에 코드를 넣을거라, 배치파일 하나만 돌리면 파일을 두개나오게 만들겠다는 뜻)
앞으로는 새로운 패킷기능을 추가한다면, 전달과 비직렬화까진 다 구현했으니, 기능만 PacketHandler에 직접 코딩하면 된다.
