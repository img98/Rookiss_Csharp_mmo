[ 네트워크 기초 이론 ]
서버는 다른분야보다 이론이 중요하다. 앞으로의 네트워크 패킷관련 예시는 택배관련으로 설명하겠다.
정보를 보낼때는 : 라우터(택배회사) - 스위치(경비실) - 단말기(집) 를 통해 움직인다.

[ 통신 모델 ]
 택배를 보낼때 필요한것 : 
상품(제품 준비) ,
배송정책(등기라거나, 부재시회수라거나...) ,
최종주소 ,
배달 경로(다음 목적지, 101호->경비실) ,
운송  //배달경로는 매 이동마다 바뀌지만, 최종주소는 바뀌지 않는다.

네트워크에서 보낼때 필요한것 : 
어플리케이션 (제품 준비) HTTP FTP DNS등등 
트랜스포트 (배송정책, 사고시 어떻게 처리할지) TCP-느리지만 안정적 UDP-빠르지만불안정
네트워크(네트워크간 경로설정) IPv4 IPv6 라우터와 연관
데이터 링크 (네트워크 내 경로 설정) 이더넷, PPP 스위치와 연관 
피지컬 (신호처리) 케이블 허브

위가 TCP/IP모델인데, 예전에 쓰던 OSI 7계층 모델이라는게 있다. 여기서 2계층은 데이터, 3계층은 네트워크, 7계층은 도메인 이런식으로 말이 유래됨

전달하는 데이터 패킷은 위와같은 7계층 구조의 순서대로 만들어지고 역으로 해석할수있다.

[ 소켓 프로그래밍 입문 #1 ]
소켓이란 네트워크 통신을 위한 장치를 의미한다.
다음과 같은 식당 시나리오가 있다고 생각해보자.
손님이 핸드폰 준비  - 식당번호로 입장 문의 - 휴대폰을 통해 대리인(자리 맡아주기) 휴대폰과 통화가능
식당은 문지기 고용 - 문지기 교육(현주소와 식당구조 등 교육) - 영업시작 - 안내(대리인과 손님 연결) - 손님대리인을 통해 손님과 대화가능

이것을 서버로 비교해보면
클라이언트는 소켓(핸드폰) 준비 - 서버주소(식당번호)로 Connect - 소켓을 통해 Session소켓(대리인)과 패킷송수신(통화)가능
서버입장에선 Listener소켓(문지기) 준비 - Bind(서버주소 / Port를 소켓에 연동) - Listening(영업시작) - Accept - 클라 세션을 통해 손님과 통화 가능

!사실 흐름설명이 좀 어거지라서 그냥 코드보고 이해하는게 더 낫다.
!! 클라보다 서버가 할일이 많다. 소켓(핸드폰)의 존재 가 있다는것정도만 알아두자

[ 소켓 프로그래밍 입문 #2 ]

[ Listener ]
하나의 코드가 커지면 관리하기 어려우니 분리하는 습관을 가지자. 앞서 만든 서버 코드에서 문지기(Listener)에 대한 기능들은 따로 클래스 파일을 만들어 옮겨줄것이다.
(나중에 데이터를 보내고 받는 부분도 Session으로 분리할것)

기존 리스너에서 맘에 안들던건, 손님을 입장시킬 때, Accept()라는 blocking함수를 쓰는게 맘에 안들던것. <=기껏 여러 쓰레드를 만들었는데 accept하나때문에 쓰레드가 정지해있음(지금상황은 크게 문제될것없지만, 다른코드에서는 블락킹 안쓰는게 좋음)
블락킹은 mmo상황에서 가능한 피하는게 좋으므로 이것을 개선시키자.(논 블락킹으로 AcceptAsync) Async=비동기
비동기 문법은, 일단 코드가 진행되다가 나중에 필요로할때 콜백형식으로 처리하게된다.

! Async를써서 논블락킹으로 만들면, 결국 처음에 한번 요청을 받는 코드를 수동으로 시행하고, 코드가 들어오면 콜백방식으로 기능을 처리한 후에, 바로 새로운 요청을 받는 코드가 작동되는 형태로 되어있다.
(리스너를 예로들면, 처음에 RegisterAccpet를 수동으로 실행하면, 그후에 자동으로 OnAccpetCompleted가 실행되고, 그후다시 RegisterAccpet가 자동으로 실행된다.)
얼핏보면 간단하지만 위함수가 계속 반복된다는 것이 너무나 중요하다.


[ Session #1 ]
지난 리스너에서, 만약 수많은 로그인접속이 있을것이라 예상되면, 처음 Init에서 args와 콜백함수 연결, RegisterAccept 실행을 여러개 해주면된다.(마치 낚싯대를 여러개로 늘리듯이)
이번에는 서버에서 데이터를 받는걸(Receive) 분리시켜보겠다.
OnAcceptHandler뒤에 손님을 받은후, 받고 보내는 작업을 했으니 이걸 수정하면 되겠다.

Receive의 경우 지난 listener처럼 요청받기를 한번 툭 던져놓으면 알아서 콜백으로 실행하면되서 listener때와 같이 간단했다.
하지만 Sender로 가면, 우리가 원하는 타이밍에 send를 호출해야하기에 방법도 여러가지고 조금 복잡함.

[ Session #2 ]
Receiver같은 경우는 낚싯대가 하나밖에 없으니, 멀티쓰레드의 문제가 없지만 Send같은 경우에는 완전히 달라지게 된다.

Send의 가장큰 문제점 : 보내는 시점이 정해져있지않음. (Receive나 Listener는 그저 받을때까지 기다려도 됬지만 send는 아니다.)

그리고 대규모 MMO같은 경우에, 매 행동마다 SendAsync를 사용할수는 없는 노릇이다.(나중에 나오겠지만, send하는 작업도 부하가 좀 있는 작업임)

이번강의에서 핵심은 _sendArgs를 하나만 만들어서 재사용하게 한것.

[ Session #3 ]
지난강의에서 주요내용 = Receive Args와 Send Args를 사용하는 방법

send를 개선하는 과정에서 _pendingList를 추가시켜, 일일이 큐에 버프를 담지않고, 리스트에 담았다가 한번에 보내줌. 또한 이걸로 인해, _pending이 필요없어짐
(참고: pending과 _pending은 다른것이다! pending은 RegisterSend가 돌고있는지 확인하기위함, _pending은 send가 사용되는지 확인하기위함)

더 개선하자면 OnRecvCompleted단계에서 들어오는 패킷량을 보고 ddos공격마냥 무의미한 데이터가 지속적으로 오면 disconnect를 해줄수있겠고,
send에서 비록 BuffList를 통해 뭉쳐서 보냈지만, 이걸 더 뭉쳐서 해당 게임지역에서 일어난 데이터를 한번에 보내게 해도 성능 개선이 예상된다.

[ Session #4 ]
EventHandler를 통해 Session을 더욱 개선해보자.
지금까지 send RegisterSend Disconnect OnRecvCompleted 등등 여러 로직을 만들었지만, 사실 실사용때는 OnSend, OnRecv등 사용을 위한 함수만 건드릴것이지, 로직에는 관심 없을것이다.
위 사용부는 서버 프로그램에서 돌릴수있게, 세션에서 abstract class로 만들고, 서버에서 Session을 상속받은 GameSession이라는 클래스를 만들어 사용하자.

즉, 엔진과 컨텐츠를 분리하는것임. (세션에서는 게임에서 멀할진 모르지만, RecvCompleted가 되면 OnRecv에게 콜백 사인을 줄거고, 서버에서는 왜 RecvComplete가 되는진 모르지만 OnRecv신호가오면 무슨일을 할지 코딩하는것)