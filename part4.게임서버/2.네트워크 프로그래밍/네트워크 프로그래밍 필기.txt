[ 네트워크 기초 이론 ]
서버는 다른분야보다 이론이 중요하다. 앞으로의 네트워크 패킷관련 예시는 택배관련으로 설명하겠다.
정보를 보낼때는 : 라우터(택배회사) - 스위치(경비실) - 단말기(집) 를 통해 움직인다.

[ 통신 모델 ]
 택배를 보낼때 필요한것 : 
상품(제품 준비) ,
배송정책(등기라거나, 부재시회수라거나...) ,
최종주소 ,
배달 경로(다음 목적지, 101호->경비실) ,
운송  //배달경로는 매 이동마다 바뀌지만, 최종주소는 바뀌지 않는다.

네트워크에서 보낼때 필요한것 : 
어플리케이션 (제품 준비) HTTP FTP DNS등등 
트랜스포트 (배송정책, 사고시 어떻게 처리할지) TCP-느리지만 안정적 UDP-빠르지만불안정
네트워크(네트워크간 경로설정) IPv4 IPv6 라우터와 연관
데이터 링크 (네트워크 내 경로 설정) 이더넷, PPP 스위치와 연관 
피지컬 (신호처리) 케이블 허브

위가 TCP/IP모델인데, 예전에 쓰던 OSI 7계층 모델이라는게 있다. 여기서 2계층은 데이터, 3계층은 네트워크, 7계층은 도메인 이런식으로 말이 유래됨

전달하는 데이터 패킷은 위와같은 7계층 구조의 순서대로 만들어지고 역으로 해석할수있다.

[ 소켓 프로그래밍 입문 #1 ]
소켓이란 네트워크 통신을 위한 장치를 의미한다.
다음과 같은 식당 시나리오가 있다고 생각해보자.
손님이 핸드폰 준비  - 식당번호로 입장 문의 - 휴대폰을 통해 대리인(자리 맡아주기) 휴대폰과 통화가능
식당은 문지기 고용 - 문지기 교육(현주소와 식당구조 등 교육) - 영업시작 - 안내(대리인과 손님 연결) - 손님대리인을 통해 손님과 대화가능

이것을 서버로 비교해보면
클라이언트는 소켓(핸드폰) 준비 - 서버주소(식당번호)로 Connect - 소켓을 통해 Session소켓(대리인)과 패킷송수신(통화)가능
서버입장에선 Listener소켓(문지기) 준비 - Bind(서버주소 / Port를 소켓에 연동) - Listening(영업시작) - Accept - 클라 세션을 통해 손님과 통화 가능

!사실 흐름설명이 좀 어거지라서 그냥 코드보고 이해하는게 더 낫다.
!! 클라보다 서버가 할일이 많다. 소켓(핸드폰)의 존재 가 있다는것정도만 알아두자

[ 소켓 프로그래밍 입문 #2 ]

[ Listener ]
하나의 코드가 커지면 관리하기 어려우니 분리하는 습관을 가지자. 앞서 만든 서버 코드에서 문지기(Listener)에 대한 기능들은 따로 클래스 파일을 만들어 옮겨줄것이다.
(나중에 데이터를 보내고 받는 부분도 Session으로 분리할것)

기존 리스너에서 맘에 안들던건, 손님을 입장시킬 때, Accept()라는 blocking함수를 쓰는게 맘에 안들던것. <=기껏 여러 쓰레드를 만들었는데 accept하나때문에 쓰레드가 정지해있음(지금상황은 크게 문제될것없지만, 다른코드에서는 블락킹 안쓰는게 좋음)
블락킹은 mmo상황에서 가능한 피하는게 좋으므로 이것을 개선시키자.(논 블락킹으로 AcceptAsync) Async=비동기
비동기 문법은, 일단 코드가 진행되다가 나중에 필요로할때 콜백형식으로 처리하게된다.

! Async를써서 논블락킹으로 만들면, 결국 처음에 한번 요청을 받는 코드를 수동으로 시행하고, 코드가 들어오면 콜백방식으로 기능을 처리한 후에, 바로 새로운 요청을 받는 코드가 작동되는 형태로 되어있다.
(리스너를 예로들면, 처음에 RegisterAccpet를 수동으로 실행하면, 그후에 자동으로 OnAccpetCompleted가 실행되고, 그후다시 RegisterAccpet가 자동으로 실행된다.)
얼핏보면 간단하지만 위함수가 계속 반복된다는 것이 너무나 중요하다.


[ Session #1 ]
지난 리스너에서, 만약 수많은 로그인접속이 있을것이라 예상되면, 처음 Init에서 args와 콜백함수 연결, RegisterAccept 실행을 여러개 해주면된다.(마치 낚싯대를 여러개로 늘리듯이)
이번에는 서버에서 데이터를 받는걸(Receive) 분리시켜보겠다.
OnAcceptHandler뒤에 손님을 받은후, 받고 보내는 작업을 했으니 이걸 수정하면 되겠다.

Receive의 경우 지난 listener처럼 요청받기를 한번 툭 던져놓으면 알아서 콜백으로 실행하면되서 listener때와 같이 간단했다.
하지만 Sender로 가면, 우리가 원하는 타이밍에 send를 호출해야하기에 방법도 여러가지고 조금 복잡함.

[ Session #2 ]
Receiver같은 경우는 낚싯대가 하나밖에 없으니, 멀티쓰레드의 문제가 없지만 Send같은 경우에는 완전히 달라지게 된다.

Send의 가장큰 문제점 : 보내는 시점이 정해져있지않음. (Receive나 Listener는 그저 받을때까지 기다려도 됬지만 send는 아니다.)

그리고 대규모 MMO같은 경우에, 매 행동마다 SendAsync를 사용할수는 없는 노릇이다.(나중에 나오겠지만, send하는 작업도 부하가 좀 있는 작업임)

이번강의에서 핵심은 _sendArgs를 하나만 만들어서 재사용하게 한것.

[ Session #3 ]
지난강의에서 주요내용 = Receive Args와 Send Args를 사용하는 방법

send를 개선하는 과정에서 _pendingList를 추가시켜, 일일이 큐에 버프를 담지않고, 리스트에 담았다가 한번에 보내줌. 또한 이걸로 인해, _pending이 필요없어짐
(참고: pending과 _pending은 다른것이다! pending은 RegisterSend가 돌고있는지 확인하기위함, _pending은 send가 사용되는지 확인하기위함)

더 개선하자면 OnRecvCompleted단계에서 들어오는 패킷량을 보고 ddos공격마냥 무의미한 데이터가 지속적으로 오면 disconnect를 해줄수있겠고,
send에서 비록 BuffList를 통해 뭉쳐서 보냈지만, 이걸 더 뭉쳐서 해당 게임지역에서 일어난 데이터를 한번에 보내게 해도 성능 개선이 예상된다.

[ Session #4 ]
EventHandler를 통해 Session을 더욱 개선해보자.
지금까지 send RegisterSend Disconnect OnRecvCompleted 등등 여러 로직을 만들었지만, 사실 실사용때는 OnSend, OnRecv등 사용을 위한 함수만 건드릴것이지, 로직에는 관심 없을것이다.
위 사용부는 서버 프로그램에서 돌릴수있게, 세션에서 abstract class로 만들고, 서버에서 Session을 상속받은 GameSession이라는 클래스를 만들어 사용하자.

즉, 엔진과 컨텐츠를 분리하는것임. (세션에서는 게임에서 멀할진 모르지만, RecvCompleted가 되면 OnRecv에게 콜백 사인을 줄거고, 서버에서는 왜 RecvComplete가 되는진 모르지만 OnRecv신호가오면 무슨일을 할지 코딩하는것)

[ Connector ]
Listener의 반대역할을 하는 connector (반대라기보단, DummyClient가 서버에 connect요청을 보내는걸 말한다.)
그동안은 socket.Connect(endPoint);를 통해 블락킹함수를 사용했지만, 계속해왔듯 논블락킹으로 바꾸려한다.

커넥터는 client에서 서버로 보내는 요청인데 왜 커넥터를 서버에 구현하나?
1. 연결과 receive send를 공용으로 쓰면 편하니까.
2. 아이템만 관리하는 서버, npc만 관리하는 서버 처럼 분할해서 서버를 만드는경우, 서버가 다른서버랑 연결하려면 결국 connector가 필요함

그런데 생각해보면 서버코어에 커넥터를 구현해서, DummyClient는 얘네를 갖다 쓸수가 없다.
=> ServerCore의 속성으로 가서 출력형식을 '클래스 라이브러리'로 설정한다. =말그대로 라이브러리로 만든것
이후, DummyClient와 Server에 가서 추가-프로젝트 참조 를 통해 ServerCore라이브러리를 참조하도록 하면된다.

[ TCP vs UDP ]
TCP의 경우 네트워크 부하가 예상된다면, 100바이트를 보내라고 요청을해도 100바이트를 전부 보내지 않을수도 있다.
TCP는 트랜스포트(배송정책)에 해당되는 영역이다.

TCP와 UDP의 차이를 자세히 알아보자.
쉽게말하면 TCP는 안전한 트럭배송, 전화와 같고 / UDP는 위험한 총알배송, 메일과 같다(안정성과 속도가 반비례)

<연결지향성>
TCP = 연결형 서비스 & 전송순서가 보장되어야한다. 
UDP = 비연결형 서비스(연결이라는 개념이 없다. 그저 우편을 우체통에 넣으면 끝), 전송순서를 보장하지 않는다(늦게보낸사람(데이터)가 먼저 도착해도 된다.).

<속도와 신뢰성>
신뢰성 = 데이터 분실에 대한 책임(또는 대처)를 어떻게 하느냐
TCP = 분실시 다시전송, 물건주고받을상황이 아니면 일부만 보냄(혼잡제어) => 고려할게 많으니 속도 나쁨
UDP = 분실시 책임없음, 일단 보내고 생각 => 단순하니 빠름

위에서 '전송순서' 와 '신뢰성' 이 게임제작에 굉장히 중요하다

//tcp의 신뢰성이 마냥 좋은건 아님. 앞서 tcp는 물건을 일부만 보낼수있다고 했는데, 이것이 서버입장에서는 곤란할수도있다.
//사실 tcp도 그렇게느린건아니라서, udp를 특수한 경우에만 사용한다.

[ RecvBuffer ]
실제론 tcp특성에 의해 100바이트를 보내라고 요청을해도 100바이트를 전부 보내지 않을수도 있다 하였다.
=>이걸 막기위해서, 80바이트만 오면, 일단 보관해놨다가 나중에 20바이트가 더오면 그제야 빈부분을 완성시켜서 사용하게 하면된다.
즉, _recvArgs.SetBuffer(new byte[1024], 80, 1024); 과 같이 시작위치 인자를 고쳐준다.

! 버퍼를 나눠서 일부분만 활용할수있게 만든것이 핵심

[ SendBuffer ]
리시브버퍼는 유저마다 무슨 요청을 보내는지 알아야하니까, 각각의 버퍼를 만들어주면 됬다. (세션과 리시브버퍼가 1대1 관계였고 그렇기에 구현 관리 편했다.)
하지만 센드버퍼는 보내는 순간, 외부에서 버퍼배열을 만들어 여러개의 정보를 뭉쳐서 한번에 보냈다
(외부에서 만드는 이유는, 한동작 한동작마다 모든 유저들에게 send를 하면 필요한 리소스가 겁나게 많이듬. 예를들면 1명이동->이동패킷을 100명에게뿌림. 100명이이동 ->이동패킷 100명*100명 1만개 뿌려야됨
그러나, 100명의 이동을 하나의 데이터패킷으로 외부에서 묶으면, 그 패킷을 100번 보내기만 하면됨)

센드버퍼의 문제점은 앞선 리시브버퍼마냥 크기를 설정해줄수 없다는것, 예를들면 캐릭터이름, 스킬보유갯수등 크기가 변할수있는 인자가 너무많고
상황마다 최적의 버퍼 사이즈가 다름(무작정 new byte[1024]라 할수없다는것, 남으면 낭비니까)
=> 그럼 큰 버퍼를 만들고, 필요할때마다 조금씩 잘라쓰면 되겠다.(저번에 readPos, writePos한것처럼) = 해보자

//사실 패킷직렬화를 배우면 이런 코드를 사용할일이 없어지는데,
 그냥 공용으로 쓰는 큰 버퍼 배열을 필요한만큼 조금씩 잘라쓴다는것이 핵심임
 
[ PacketSession ]
기존 session을 개선시킬거다. 지금까진 바이트를 담은 버퍼(ArraySegment)를 통해 송수신을 했지만, 이것을 일반적인 패킷으로 보내는법을 알아보자.
기본적으로 패킷 클래스에는 패킷ID를 넣어주는데, 이것을 통해 어떤 기능을 하게될지 알리는것이다(1이면 공격패킷, 2면 피해패킷..) 그런데 패킷id만 보낼경우, 각 기능들마다 사이즈가 다르기에
패킷에는 패킷의 size까지 넣어서 보내게된다..

패킷의 구조? [size(2)][packetId(2)][....][size(2)][packetId(2)][....]
!결국 먼저 2바이트로 사이즈를 보내고, 2바이트로 무슨기능인지 보내고, 내용을 보내는 패킷의 구조를 아는것이 핵심.